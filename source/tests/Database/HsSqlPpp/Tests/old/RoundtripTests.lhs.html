<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >RoundtripTests</title
    ><link href="../../../../../../main.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><div class="header"
    ><a href="../../../../../../index.html"
      >HsSqlPpp-0.3.0</a
      ></div
    ><br
     /><br
     /><br
     /><p
    >Test sql by typechecking it, then running it through Postgres and comparing:</p
    ><ul
    ><li
      >compare the catalog from typechecking to the one read from postgres</li
      ><li
      >load then dump the sql and compare post and pre asts</li
      ><li
      >(NOT STARTED ON YET) create views and check the type from type checking to the one from pg</li
      ></ul
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="Keyword">module</span> <span class="ConId">Database.HsSqlPpp.Tests.RoundtripTests</span> <span class="Symbol">(</span><span class="VarId">roundtripTests</span><span class="Symbol">)</span> <span class="Keyword">where</span>

<span class="Keyword">import</span> <span class="ConId">Test.HUnit</span>
<span class="Keyword">import</span> <span class="ConId">Test.Framework</span>
<span class="Keyword">import</span> <span class="ConId">Test.Framework.Providers.HUnit</span>
<span class="Keyword">import</span> <span class="ConId">Control.Monad.Error</span>
<span class="Keyword">import</span> <span class="ConId">Data.List</span>
<span class="Keyword">import</span> <span class="ConId">Data.Generics</span>
<span class="Keyword">import</span> <span class="ConId">Data.Generics.PlateData</span>
<span class="Keyword">import</span> <span class="ConId">Data.Char</span>

<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Utils.Utils</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Utils.Here</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Parser</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Catalog</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.TypeChecker</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Utils.DBUtils</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Utils.DatabaseLoader</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Annotation</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Ast</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.SqlTypes</span></pre></div></div></div><p
    >slightly dodgy, these tests automatically connect to this database and clear it. hopefully no-one running these tests is storing important data in a database with this name</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">testDatabaseName</span> <span class="Symbol">::</span> <span class="ConId">String</span>
<span class="Function">testDatabaseName</span> <span class="Symbol">=</span> <span class="String">&quot;hssqlpppautomatedtests&quot;</span>

<span class="Keyword">data</span> <span class="ConId">Item</span> <span class="Symbol">=</span> <span class="ConId">Group</span> <span class="ConId">String</span> <span class="Symbol">[</span><span class="ConId">Item</span><span class="Symbol">]</span>
          <span class="Symbol">|</span> <span class="ConId">Src</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">String</span><span class="Symbol">)]</span>

<span class="Function">roundtripTests</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">Test.Framework.Test</span><span class="Symbol">]</span>
<span class="Function">roundtripTests</span> <span class="Symbol">=</span> <span class="VarId">itemToTft</span> <span class="VarId">roundtripTestData</span>

<span class="Function">roundtripTestData</span> <span class="Symbol">::</span> <span class="ConId">Item</span>
<span class="Function">roundtripTestData</span> <span class="Symbol">=</span>
    <span class="ConId">Group</span> <span class="String">&quot;round trip tests&quot;</span> <span class="Symbol">[</span> <span class="ConId">Src</span> <span class="Symbol">[</span>
      <span class="Symbol">(</span><span class="String">&quot;simple select&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;select 1 from pg_attrdef;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create domain&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create domain testd as text;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create domain with check&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create domain testd as text check (length(value) &gt; 2);&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create composite&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create type pos as (\n\
       \  x int,\n\
       \  y int);&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create table&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create table ttable (\n\
       \  x int,\n\
       \  y int);&quot;</span><span class="Symbol">)</span>
     <span class="Comment">--,(&quot;create table with constraints&quot;</span>
     <span class="Comment">-- ,&quot;create table ttable (\n\</span>
     <span class="Comment">--  \  x int primary key,\n\</span>
     <span class="Comment">--  \  y int not null);&quot;)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create view&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create view v1 as select * from pg_attrdef;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create function&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create function test1() returns integer as $$\n\
       \  select 1;\n\
       \$$ language sql;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;create plpgsql function&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;create language plpgsql;\n\
       \create function test1() returns void as $$\n\
       \begin\n\
       \  null;\n\
       \end;\n\
       \$$ language plpgsql;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;join associativity&quot;</span>
      <span class="Symbol">,</span><span class="String">&quot;select * from pg_enum full outer join pg_largeobject on true full outer join pg_listener on true;&quot;</span><span class="Symbol">)</span>
     <span class="Symbol">,(</span><span class="String">&quot;with and union associativity&quot;</span>
      <span class="Symbol">,[$</span><span class="VarId">here</span><span class="Symbol">|</span>
        <span class="VarId">create</span> <span class="VarId">view</span> <span class="VarId">v1</span> <span class="Keyword">as</span>
        <span class="VarId">with</span>
          <span class="VarId">a</span> <span class="Keyword">as</span> <span class="Symbol">(</span><span class="VarId">select</span> <span class="Number">1</span><span class="Symbol">)</span>
         <span class="Symbol">,</span><span class="VarId">b</span> <span class="Keyword">as</span> <span class="Symbol">(</span><span class="VarId">select</span> <span class="Number">2</span><span class="Symbol">)</span>
         <span class="VarId">select</span> <span class="Symbol">*</span> <span class="VarId">from</span> <span class="VarId">a</span>
         <span class="VarId">union</span> <span class="VarId">select</span> <span class="Symbol">*</span> <span class="VarId">from</span> <span class="VarId">b</span><span class="Symbol">;|])</span>
    <span class="Symbol">]]</span></pre></div></div></div><pre
    ><code
      >TODO for test data:
run through constraints in create table after attribute and as seperate rows
do multiple constraints on a line
use create view to run through select variations
</code
      ></pre
    ><hr
     /><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">itemToTft</span> <span class="Symbol">::</span> <span class="ConId">Item</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">Test.Framework.Test</span><span class="Symbol">]</span>
<span class="Function">itemToTft</span> <span class="Symbol">(</span><span class="ConId">Group</span> <span class="VarId">s</span> <span class="VarId">is</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="VarId">testGroup</span> <span class="VarId">s</span> <span class="Symbol">$</span> <span class="VarId">concatMap</span> <span class="VarId">itemToTft</span> <span class="VarId">is</span><span class="Symbol">]</span>
<span class="Function">itemToTft</span> <span class="Symbol">(</span><span class="ConId">Src</span> <span class="VarId">ss</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">uncurry</span> <span class="VarId">testRoundtrip</span><span class="Symbol">)</span> <span class="VarId">ss</span>

<span class="Function">testRoundtrip</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">Test.Framework.Test</span>
<span class="Function">testRoundtrip</span> <span class="VarId">name</span> <span class="VarId">sql</span> <span class="Symbol">=</span> <span class="VarId">testCase</span> <span class="Symbol">(</span><span class="String">&quot;test &quot;</span> <span class="Symbol">++</span> <span class="VarId">name</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">wrapETT</span> <span class="Symbol">$</span> <span class="Keyword">do</span>
  <span class="VarId">astOrig</span> <span class="Symbol">&lt;-</span> <span class="VarId">tsl</span> <span class="Symbol">$</span> <span class="VarId">parseSql</span> <span class="String">&quot;&quot;</span> <span class="VarId">sql</span>
  <span class="Keyword">let</span> <span class="Symbol">(</span><span class="VarId">catOrig</span><span class="Symbol">,</span> <span class="VarId">astOrigTC</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">typeCheck</span> <span class="VarId">defaultTemplate1Catalog</span> <span class="VarId">astOrig</span>
  <span class="VarId">failIfTypeErrors</span> <span class="VarId">astOrigTC</span>
  <span class="Comment">-- run the tests first using psql to load the sql into the database</span>
  <span class="Comment">-- and then using hssqlppp's database loader to load the sql into</span>
  <span class="Comment">-- the database</span>
  <span class="VarId">doPgTests</span> <span class="VarId">astOrig</span> <span class="VarId">catOrig</span> <span class="Symbol">(</span><span class="VarId">liftIO</span> <span class="Symbol">(</span><span class="VarId">loadSqlUsingPsql</span> <span class="VarId">testDatabaseName</span> <span class="VarId">sql</span> <span class="Symbol">&gt;&gt;</span> <span class="VarId">return</span> <span class="Symbol">()))</span>
  <span class="VarId">doPgTests</span> <span class="VarId">astOrig</span> <span class="VarId">catOrig</span> <span class="Symbol">(</span><span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">loadAstN</span> <span class="VarId">testDatabaseName</span> <span class="VarId">astOrig</span><span class="Symbol">)</span>
  <span class="Keyword">where</span>
    <span class="VarId">doPgTests</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">Statement</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">ErrorT</span> <span class="ConId">String</span> <span class="ConId">IO</span> <span class="Symbol">()</span> <span class="Symbol">-&gt;</span> <span class="ConId">ErrorT</span> <span class="ConId">String</span> <span class="ConId">IO</span> <span class="Symbol">()</span> <span class="Comment">-- a -&gt; a</span>
    <span class="VarId">doPgTests</span> <span class="VarId">astOrig</span> <span class="VarId">catOrig</span> <span class="VarId">loadIntoDb</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
      <span class="Comment">-- parse and type check the test sql</span>
      <span class="Comment">-- load this sql into pg</span>
      <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">clearDBN</span> <span class="VarId">testDatabaseName</span>
      <span class="VarId">loadIntoDb</span>
      <span class="Comment">-- check the catalog in pg is the same as the one from type checking</span>
      <span class="VarId">catPsql</span> <span class="Symbol">&lt;-</span> <span class="VarId">liftIO</span> <span class="Symbol">(</span><span class="VarId">readCatalog</span> <span class="VarId">testDatabaseName</span><span class="Symbol">)</span> <span class="Symbol">&gt;&gt;=</span> <span class="VarId">tsl</span>
      <span class="VarId">compareCats</span> <span class="String">&quot;load&quot;</span> <span class="VarId">catOrig</span> <span class="VarId">catPsql</span>
      <span class="Comment">-- dump the database to get the sql having been normalized by passing</span>
      <span class="Comment">-- it through pg's digestive system</span>
      <span class="VarId">dumpSql</span> <span class="Symbol">&lt;-</span> <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">pgDump</span> <span class="VarId">testDatabaseName</span>
      <span class="VarId">astDumped</span> <span class="Symbol">&lt;-</span> <span class="VarId">tsl</span> <span class="Symbol">$</span> <span class="VarId">parseSql</span> <span class="String">&quot;&quot;</span> <span class="VarId">dumpSql</span>
      <span class="Keyword">let</span> <span class="Symbol">(</span><span class="VarId">catDumped</span><span class="Symbol">,</span> <span class="VarId">astDumpedTC</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">typeCheck</span> <span class="VarId">defaultTemplate1Catalog</span> <span class="VarId">astDumped</span>
      <span class="VarId">failIfTypeErrors</span> <span class="VarId">astDumpedTC</span>
      <span class="Comment">-- check the original catalog from the catalog gotten from</span>
      <span class="Comment">-- dumping then typechecking the dump, maybe a little excessive</span>
      <span class="VarId">compareCats</span> <span class="String">&quot;dump&quot;</span> <span class="VarId">catOrig</span> <span class="VarId">catDumped</span>
      <span class="Comment">-- compare the original ast to the dump ast, uses a transform</span>
      <span class="Comment">-- to match the changes that happen to the sql when loaded</span>
      <span class="Comment">-- then dumped by pg</span>
      <span class="Keyword">let</span> <span class="VarId">astOrigAdj</span> <span class="Symbol">=</span> <span class="VarId">adjustAstToLookLikeDump</span> <span class="Symbol">$</span> <span class="VarId">adjTree</span> <span class="VarId">astOrig</span>
          <span class="VarId">astDumpedAdj</span> <span class="Symbol">=</span> <span class="VarId">adjTree</span> <span class="VarId">astDumped</span>
      <span class="Comment">-- do this when a test fails to help diagnose why</span>
      <span class="VarId">when</span> <span class="Symbol">(</span><span class="VarId">astOrigAdj</span> <span class="Symbol">/=</span> <span class="VarId">astDumpedAdj</span><span class="Symbol">)</span> <span class="Symbol">$</span>
            <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">putStrLn</span> <span class="Symbol">$</span> <span class="VarId">sql</span> <span class="Symbol">++</span> <span class="String">&quot;\n&quot;</span> <span class="Symbol">++</span> <span class="VarId">dumpSql</span>
      <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">assertEqual</span> <span class="String">&quot;check dump ast&quot;</span> <span class="VarId">astOrigAdj</span> <span class="VarId">astDumpedAdj</span>

    <span class="VarId">compareCats</span> <span class="VarId">s</span> <span class="VarId">c1</span> <span class="VarId">c2</span> <span class="Symbol">=</span>
      <span class="Keyword">case</span> <span class="VarId">compareCatalogs</span> <span class="VarId">defaultTemplate1Catalog</span> <span class="VarId">c1</span> <span class="VarId">c2</span> <span class="Keyword">of</span>
              <span class="ConId">CatalogDiff</span> <span class="Symbol">[]</span> <span class="Symbol">[]</span> <span class="Symbol">-&gt;</span> <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">return</span> <span class="Symbol">()</span>
              <span class="VarId">c</span> <span class="Symbol">-&gt;</span> <span class="VarId">liftIO</span> <span class="Symbol">$</span> <span class="VarId">assertFailure</span> <span class="Symbol">$</span> <span class="VarId">s</span> <span class="Symbol">++</span> <span class="String">&quot;, catalogs different: &quot;</span> <span class="Symbol">++</span> <span class="VarId">ppCatDiff</span> <span class="VarId">c</span>
    <span class="Comment">-- adjust tree is the normalization that we run on the original ast as</span>
    <span class="Comment">-- well as the dumped ast</span>
    <span class="VarId">adjTree</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">Statement</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">Statement</span><span class="Symbol">]</span>
    <span class="VarId">adjTree</span> <span class="Symbol">=</span> <span class="VarId">canonicalizeTypeNames</span> <span class="Symbol">.</span> <span class="VarId">resetAnnotations</span>
    <span class="VarId">failIfTypeErrors</span> <span class="VarId">xast</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
      <span class="Keyword">let</span> <span class="VarId">te</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span>
          <span class="VarId">te</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="VarId">x</span> <span class="Symbol">|</span> <span class="VarId">x</span> <span class="Symbol">&lt;-</span> <span class="VarId">universeBi</span> <span class="VarId">xast</span><span class="Symbol">]</span>
      <span class="VarId">unless</span> <span class="Symbol">(</span><span class="VarId">null</span> <span class="VarId">te</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">throwError</span> <span class="Symbol">$</span> <span class="VarId">show</span> <span class="VarId">te</span></pre></div></div></div><p
    >take the parse tree and change the type names to the canonical versions</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">canonicalizeTypeNames</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span>
<span class="Function">canonicalizeTypeNames</span> <span class="Symbol">=</span>
  <span class="VarId">transformBi</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span>
      <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
        <span class="ConId">SimpleTypeName</span> <span class="VarId">a</span> <span class="VarId">tn</span> <span class="Symbol">-&gt;</span> <span class="ConId">SimpleTypeName</span> <span class="VarId">a</span> <span class="Symbol">$</span> <span class="VarId">canonicalizeTypeName</span> <span class="VarId">tn</span>
        <span class="VarId">x1</span> <span class="Symbol">-&gt;</span> <span class="VarId">x1</span></pre></div></div></div><hr
     /><pre
    ><code
      ><br
	 />ast roundtrip tests:
want to compare the asts of parsed sql, with the asts of the sql
loaded into pg, dumped and parsed
issues:
some statements are split apart e.g. create table with constraints
some statements are reordered in the dump
a create, select and then drop will be a problem
so need some sort of map function to convert between, and use
extensions to cover the dynamic ddl


one of the things really want to double check is associativity and
precedence mainly in select expressions, pg_dump puts in the implicit
brackets which we can use to check these things
</code
      ></pre
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">adjustAstToLookLikeDump</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">Statement</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">Statement</span><span class="Symbol">]</span>
<span class="Function">adjustAstToLookLikeDump</span> <span class="VarId">ast</span> <span class="Symbol">=</span>
  <span class="Symbol">(</span><span class="VarId">addPresets</span> <span class="Symbol">.</span> <span class="VarId">stripDml</span> <span class="Symbol">.</span> <span class="VarId">addConstraintNames</span><span class="Symbol">)</span> <span class="VarId">ast</span>
  <span class="Keyword">where</span>
    <span class="Comment">-- add the following at the beginning of the ast, since this is what pg_dump does</span>
    <span class="Comment">-- SET statement_timeout = 0;</span>
    <span class="Comment">-- SET client_encoding = 'UTF8';</span>
    <span class="Comment">-- SET standard_conforming_strings = off;</span>
    <span class="Comment">-- SET check_function_bodies = false;</span>
    <span class="Comment">-- SET client_min_messages = warning;</span>
    <span class="Comment">-- SET escape_string_warning = off;</span>

    <span class="Comment">-- SET search_path = public, pg_catalog;</span>
    <span class="VarId">noDml</span> <span class="Symbol">=</span> <span class="VarId">stripDml</span> <span class="VarId">ast</span>
    <span class="VarId">addPresets</span> <span class="Symbol">=</span> <span class="VarId">adjustForCreatePlpgsql</span> <span class="Symbol">.</span> <span class="Symbol">(</span><span class="VarId">presets</span> <span class="Symbol">++)</span>
    <span class="VarId">adjustForCreatePlpgsql</span> <span class="Symbol">=</span>
      <span class="VarId">transformBi</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span>
          <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
            <span class="VarId">s</span><span class="Symbol">@(</span><span class="ConId">Set</span> <span class="VarId">_</span> <span class="String">&quot;search_path&quot;</span> <span class="VarId">_</span><span class="Symbol">):</span><span class="VarId">s1</span><span class="Symbol">@(</span><span class="ConId">CreateLanguage</span> <span class="VarId">_</span> <span class="VarId">_</span><span class="Symbol">):</span><span class="VarId">s2</span> <span class="Symbol">-&gt;</span> <span class="VarId">s1</span><span class="Symbol">:</span><span class="VarId">s</span><span class="Symbol">:</span><span class="VarId">s2</span>
            <span class="VarId">z</span> <span class="Symbol">-&gt;</span> <span class="VarId">z</span>
    <span class="VarId">presets</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;statement_timeout&quot;</span> <span class="Symbol">[</span><span class="ConId">SetNum</span> <span class="VarId">ea</span> <span class="Number">0.0</span><span class="Symbol">]</span>
              <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;client_encoding&quot;</span> <span class="Symbol">[</span><span class="ConId">SetStr</span> <span class="VarId">ea</span> <span class="String">&quot;UTF8&quot;</span><span class="Symbol">]</span>
              <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;standard_conforming_strings&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;off&quot;</span><span class="Symbol">]</span>
              <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;check_function_bodies&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;false&quot;</span><span class="Symbol">]</span>
              <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;client_min_messages&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;warning&quot;</span><span class="Symbol">]</span>
              <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;escape_string_warning&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;off&quot;</span><span class="Symbol">]]</span>
              <span class="Comment">-- if there are no statements, pg_dump doesn't spit out the search path</span>
              <span class="Symbol">++</span> <span class="Keyword">if</span> <span class="VarId">null</span> <span class="VarId">noDml</span> <span class="Keyword">then</span> <span class="Symbol">[]</span> <span class="Keyword">else</span>
                     <span class="Symbol">[</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;search_path&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;public&quot;</span><span class="Symbol">,</span> <span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;pg_catalog&quot;</span><span class="Symbol">]]</span>
              <span class="Comment">-- these two sets get added if there are create tables</span>
              <span class="Symbol">++</span> <span class="Keyword">case</span> <span class="VarId">flip</span> <span class="VarId">find</span> <span class="VarId">ast</span> <span class="Symbol">(\</span><span class="VarId">s</span> <span class="Symbol">-&gt;</span>
                                  <span class="Keyword">case</span> <span class="VarId">s</span> <span class="Keyword">of</span>
                                    <span class="ConId">CreateTable</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">True</span>
                                    <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span><span class="Symbol">)</span> <span class="Keyword">of</span>
                   <span class="ConId">Nothing</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[]</span>
                   <span class="ConId">Just</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;default_tablespace&quot;</span> <span class="Symbol">[</span><span class="ConId">SetStr</span> <span class="VarId">ea</span> <span class="String">&quot;&quot;</span><span class="Symbol">]</span>
                             <span class="Symbol">,</span><span class="ConId">Set</span> <span class="VarId">ea</span> <span class="String">&quot;default_with_oids&quot;</span> <span class="Symbol">[</span><span class="ConId">SetId</span> <span class="VarId">ea</span> <span class="String">&quot;false&quot;</span><span class="Symbol">]]</span>
    <span class="Comment">-- dml statements don't appear in the dump</span>
    <span class="VarId">stripDml</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(\</span><span class="VarId">s</span> <span class="Symbol">-&gt;</span> <span class="Keyword">case</span> <span class="VarId">s</span> <span class="Keyword">of</span>
                               <span class="ConId">SelectStatement</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">Insert</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">Update</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">Delete</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">Copy</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">CopyData</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="ConId">Truncate</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">False</span>
                               <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">True</span><span class="Symbol">)</span></pre></div></div></div><p
    >when pg comes across a constraint without a name, it generates one automatically and this appears in the dump, so try to follow the generation here, also any 'value' identifiers will be in uppercase</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">addConstraintNames</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span>
<span class="Function">addConstraintNames</span> <span class="Symbol">=</span>
  <span class="VarId">transformBi</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span>
      <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
        <span class="ConId">CreateDomain</span> <span class="VarId">a</span> <span class="VarId">name</span> <span class="VarId">base</span> <span class="String">&quot;&quot;</span> <span class="VarId">cons</span> <span class="Symbol">-&gt;</span>
            <span class="ConId">CreateDomain</span> <span class="VarId">a</span> <span class="VarId">name</span> <span class="VarId">base</span>
              <span class="Symbol">(</span><span class="Keyword">case</span> <span class="VarId">cons</span> <span class="Keyword">of</span>
                         <span class="ConId">Nothing</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;&quot;</span>
                         <span class="ConId">Just</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="VarId">name</span> <span class="Symbol">++</span> <span class="String">&quot;_check&quot;</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">upcaseValue</span> <span class="VarId">cons</span><span class="Symbol">)</span>
                  <span class="Keyword">where</span>
                    <span class="VarId">upcaseValue</span> <span class="Symbol">=</span> <span class="VarId">transformBi</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">y</span> <span class="Symbol">-&gt;</span>
                                  <span class="Keyword">case</span> <span class="VarId">y</span> <span class="Keyword">of</span>
                                    <span class="ConId">Identifier</span> <span class="VarId">a1</span> <span class="VarId">i</span> <span class="Symbol">|</span> <span class="VarId">map</span> <span class="VarId">toUpper</span> <span class="VarId">i</span> <span class="Symbol">==</span> <span class="String">&quot;VALUE&quot;</span> <span class="Symbol">-&gt;</span>
                                          <span class="ConId">Identifier</span> <span class="VarId">a1</span> <span class="String">&quot;VALUE&quot;</span>
                                    <span class="VarId">y1</span> <span class="Symbol">-&gt;</span> <span class="VarId">y1</span>
        <span class="VarId">x1</span> <span class="Symbol">-&gt;</span> <span class="VarId">x1</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">wrapETT</span> <span class="Symbol">::</span> <span class="Symbol">(</span><span class="ConId">Show</span> <span class="VarId">e</span><span class="Symbol">)</span> <span class="Symbol">=&gt;</span> <span class="ConId">ErrorT</span> <span class="VarId">e</span> <span class="ConId">IO</span> <span class="Symbol">()</span> <span class="Symbol">-&gt;</span> <span class="ConId">IO</span> <span class="Symbol">()</span>
<span class="Function">wrapETT</span> <span class="VarId">c</span> <span class="Symbol">=</span> <span class="VarId">runErrorT</span> <span class="VarId">c</span> <span class="Symbol">&gt;&gt;=</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span>
         <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
           <span class="ConId">Left</span> <span class="VarId">er</span> <span class="Symbol">-&gt;</span> <span class="VarId">assertFailure</span> <span class="Symbol">$</span> <span class="VarId">show</span> <span class="VarId">er</span>
           <span class="ConId">Right</span> <span class="VarId">l</span> <span class="Symbol">-&gt;</span> <span class="VarId">return</span> <span class="VarId">l</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">ea</span> <span class="Symbol">::</span> <span class="ConId">Annotation</span>
<span class="Function">ea</span> <span class="Symbol">=</span> <span class="VarId">emptyAnnotation</span></pre></div></div></div><br
     /><br
     /><br
     /><div class="footer"
    >generated on 01/31/11 20:00:52, hssqlppp-0.3.0</div
    ></body
  ></html
>
