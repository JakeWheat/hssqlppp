<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >TypeType</title
    ><link href="../../../../../../main.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><div class="header"
    ><a href="../../../../../../index.txt.html"
      >HsSqlPpp-0.3.0</a
      ></div
    ><br
     /><br
     /><br
     /><p
    >This file contains the data type Type. It is kept separate so we can compile the types and function information from the database separately to AstInternal.ag.</p
    ><p
    >Types overview:</p
    ><p
    >Regular types: scalarType, arrayType, composite type, domaintype we can use these anywhere.</p
    ><pre
    ><code
      >semi first class types: row, unknownstringlit (called unknown in pg) -
these can be used in some places, but not others, in particular an
expression can have this type or select can have a row with these
type, but a view can't have a column with this type (so a select can
be valid on it's own but not as a view. Not sure if Row types can be
variables, unknownstringlit definitely can't. (Update, seems a view
can have a column with type unknown.)

pseudo types - mirror pg pseudo types
Internal, LanguageHandler, Opaque probably won't ever be properly supported
Not sure exactly what Any is, can't use it in functions like the other any types?
 - update: seems that Any is like AnyElement, but multiple Anys don't
   have to have the same type.
AnyElement, AnyArray, AnyEnum, AnyNonArray - used to implement polymorphic functions,
  can only be used in these functions as params, return type (and local vars?).
Cstring - treated as variant of text?
record -dynamically typed, depends where it is used, i think is used
for type inference in function return types (so you don't have to
write the correct type, the compiler fills it in), and as a dynamically
typed variable in functions, where it can take any composite typed
value.
void is used for functions which return nothing
trigger is a tag to say a function is used in triggers, used as a
return type only
typecheckfailed is used to represent the type of anything which the code
is currently unable to type check, this usage should disappear at some
point, and then it will only represent code which doesn't type check
because of a mistake.

The Type type identifies the type of a node, but doesn't necessarily
describe the type.

Typing relational valued expressions:
use SetOfType combined with composite type for now, see if it works
out. If not, will have to add another type.
</code
      ></pre
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-# LANGUAGE FlexibleInstances,DeriveDataTypeable #-}</span>

<span class="Keyword">module</span> <span class="ConId">Database.HsSqlPpp.AstInternals.TypeType</span> <span class="Keyword">where</span>

<span class="Keyword">import</span> <span class="ConId">Control.Monad.Trans.Error</span>
<span class="Keyword">import</span> <span class="ConId">Control.Monad.Error</span>

<span class="Keyword">import</span> <span class="ConId">Data.Generics</span>
<span class="Keyword">import</span> <span class="ConId">Data.Generics.PlateData</span>

<span class="Keyword">data</span> <span class="ConId">Type</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="ConId">String</span>
          <span class="Symbol">|</span> <span class="ConId">ArrayType</span> <span class="ConId">Type</span>
          <span class="Symbol">|</span> <span class="ConId">SetOfType</span> <span class="ConId">Type</span>
            <span class="Comment">--three variations, choose better name for rowctor</span>
            <span class="Comment">--refer to composite type in catalog</span>
          <span class="Symbol">|</span> <span class="ConId">NamedCompositeType</span> <span class="ConId">String</span>
            <span class="Comment">--refer to composite type either in catalog or one generated on fly</span>
          <span class="Symbol">|</span> <span class="ConId">CompositeType</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
            <span class="Comment">--refer to anonymous composite type: the fields have no names</span>
            <span class="Comment">--these three types are equality and assign compatible if the fields</span>
            <span class="Comment">--are ignoring the names, so the fields have to be in the same order.</span>
          <span class="Symbol">|</span> <span class="ConId">AnonymousRecordType</span> <span class="Symbol">[</span><span class="ConId">Type</span><span class="Symbol">]</span> <span class="Comment">-- was rowctor</span>
          <span class="Symbol">|</span> <span class="ConId">PgRecord</span> <span class="Symbol">(</span><span class="ConId">Maybe</span> <span class="ConId">Type</span><span class="Symbol">)</span> <span class="Comment">-- can only hold namedcomposite, composite or anonymousrecord</span>
          <span class="Symbol">|</span> <span class="ConId">DomainType</span> <span class="ConId">String</span>
          <span class="Symbol">|</span> <span class="ConId">EnumType</span> <span class="ConId">String</span>
          <span class="Symbol">|</span> <span class="ConId">Pseudo</span> <span class="ConId">PseudoType</span>
          <span class="Symbol">|</span> <span class="ConId">UnknownType</span> <span class="Comment">-- represents a string literal</span>
                             <span class="Comment">-- token whose type isn't yet</span>
                             <span class="Comment">-- determined</span>
            <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span><span class="ConId">Show</span><span class="Symbol">,</span><span class="ConId">Ord</span><span class="Symbol">,</span><span class="ConId">Typeable</span><span class="Symbol">,</span><span class="ConId">Data</span><span class="Symbol">)</span>

<span class="Keyword">data</span> <span class="ConId">PseudoType</span> <span class="Symbol">=</span> <span class="ConId">Any</span>
                <span class="Symbol">|</span> <span class="ConId">AnyArray</span>
                <span class="Symbol">|</span> <span class="ConId">AnyElement</span>
                <span class="Symbol">|</span> <span class="ConId">AnyEnum</span>
                <span class="Symbol">|</span> <span class="ConId">AnyNonArray</span>
                <span class="Symbol">|</span> <span class="ConId">Cstring</span>
                <span class="Symbol">|</span> <span class="ConId">Record</span>
                <span class="Symbol">|</span> <span class="ConId">TriggerRecord</span>
                <span class="Symbol">|</span> <span class="ConId">Trigger</span>
                <span class="Symbol">|</span> <span class="ConId">Void</span>
                <span class="Symbol">|</span> <span class="ConId">Internal</span>
                <span class="Symbol">|</span> <span class="ConId">LanguageHandler</span>
                <span class="Symbol">|</span> <span class="ConId">Opaque</span>
                  <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span><span class="ConId">Show</span><span class="Symbol">,</span><span class="ConId">Ord</span><span class="Symbol">,</span><span class="ConId">Typeable</span><span class="Symbol">,</span><span class="ConId">Data</span><span class="Symbol">)</span></pre></div></div></div><p
    >this list will need reviewing, probably refactor to a completely different set of infos, also will want to add more information to these, and to provide a way of converting into a user friendly string. It is intended for this code to produce highly useful errors later on down the line.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">                   <span class="Comment">-- mostly expected,got</span>
<span class="Keyword">data</span> <span class="ConId">TypeError</span> <span class="Symbol">=</span> <span class="ConId">WrongTypes</span> <span class="ConId">Type</span> <span class="Symbol">[</span><span class="ConId">Type</span><span class="Symbol">]</span>
               <span class="Symbol">|</span> <span class="ConId">UnknownTypeError</span> <span class="ConId">Type</span>
               <span class="Symbol">|</span> <span class="ConId">UnknownTypeName</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">NoMatchingOperator</span> <span class="ConId">String</span> <span class="Symbol">[</span><span class="ConId">Type</span><span class="Symbol">]</span>
               <span class="Symbol">|</span> <span class="ConId">TypelessEmptyArray</span>
               <span class="Symbol">|</span> <span class="ConId">IncompatibleTypeSet</span> <span class="Symbol">[</span><span class="ConId">Type</span><span class="Symbol">]</span>
               <span class="Symbol">|</span> <span class="ConId">IncompatibleTypes</span> <span class="ConId">Type</span> <span class="ConId">Type</span>
               <span class="Symbol">|</span> <span class="ConId">ValuesListsMustBeSameLength</span>
               <span class="Symbol">|</span> <span class="ConId">NoRowsGivenForValues</span>
               <span class="Symbol">|</span> <span class="ConId">UnrecognisedIdentifier</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">UnrecognisedRelation</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">UnrecognisedCorrelationName</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">BadStarExpand</span>
               <span class="Symbol">|</span> <span class="ConId">AmbiguousIdentifier</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">ContextError</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">MissingJoinAttribute</span>
               <span class="Symbol">|</span> <span class="ConId">ExpressionMustBeBool</span>
               <span class="Symbol">|</span> <span class="ConId">WrongNumberOfColumns</span>
               <span class="Symbol">|</span> <span class="ConId">ExpectedDomainType</span> <span class="ConId">Type</span>
               <span class="Symbol">|</span> <span class="ConId">DomainDefNotFound</span> <span class="ConId">Type</span>
               <span class="Symbol">|</span> <span class="ConId">BadCatalogUpdate</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">TypeAlreadyExists</span> <span class="ConId">Type</span>
               <span class="Symbol">|</span> <span class="ConId">AnyAllError</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">InternalError</span> <span class="ConId">String</span>
               <span class="Symbol">|</span> <span class="ConId">FromToTypesNotSame</span> <span class="ConId">Type</span> <span class="ConId">Type</span>
                <span class="Comment">--shoved in to humour the Either Monad</span>
               <span class="Symbol">|</span> <span class="ConId">MiscError</span> <span class="ConId">String</span>
                 <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span><span class="ConId">Show</span><span class="Symbol">,</span><span class="ConId">Ord</span><span class="Symbol">,</span><span class="ConId">Typeable</span><span class="Symbol">,</span><span class="ConId">Data</span><span class="Symbol">)</span>
</pre></div></div></div><blockquote
    ><p
      >instance Error ([TypeError]) where noMsg = [MiscError &quot;Unknown error&quot;] strMsg str = [MiscError str]</p
      ></blockquote
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">instance</span> <span class="ConId">ErrorList</span> <span class="ConId">TypeError</span> <span class="Keyword">where</span>
   <span class="VarId">listMsg</span> <span class="VarId">s</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="ConId">MiscError</span> <span class="VarId">s</span><span class="Symbol">]</span></pre></div></div></div><p
    >=== canonical type name support</p
    ><p
    >Introduce some aliases to protect client code if/when the ast canonical names are changed:</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">typeSmallInt</span><span class="Symbol">,</span><span class="VarId">typeBigInt</span><span class="Symbol">,</span><span class="VarId">typeInt</span><span class="Symbol">,</span><span class="VarId">typeNumeric</span><span class="Symbol">,</span><span class="VarId">typeFloat4</span><span class="Symbol">,</span>
  <span class="VarId">typeFloat8</span><span class="Symbol">,</span><span class="VarId">typeVarChar</span><span class="Symbol">,</span><span class="VarId">typeChar</span><span class="Symbol">,</span><span class="VarId">typeBool</span> <span class="Symbol">::</span> <span class="ConId">Type</span>
<span class="Function">typeSmallInt</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;int2&quot;</span>
<span class="Function">typeBigInt</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;int8&quot;</span>
<span class="Function">typeInt</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;int4&quot;</span>
<span class="Function">typeNumeric</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;numeric&quot;</span>
<span class="Function">typeFloat4</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;float4&quot;</span>
<span class="Function">typeFloat8</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;float8&quot;</span>
<span class="Function">typeVarChar</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;varchar&quot;</span>
<span class="Function">typeChar</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;char&quot;</span>
<span class="Function">typeBool</span> <span class="Symbol">=</span> <span class="ConId">ScalarType</span> <span class="String">&quot;bool&quot;</span></pre></div></div></div><p
    >this converts the name of a type to its canonical name: try to follow the names that pg uses in a dump</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">canonicalizeTypeName</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">canonicalizeTypeName</span> <span class="VarId">s</span> <span class="Symbol">=</span>
  <span class="Keyword">case</span> <span class="Symbol">()</span> <span class="Keyword">of</span>
                  <span class="VarId">_</span> <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">smallIntNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;int2&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">intNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;int4&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">bigIntNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;int8&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">numericNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;numeric&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">float4Names</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;float4&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">float8Names</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;float8&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">varcharNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;varchar&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">charNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;char&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">s</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">boolNames</span> <span class="Symbol">-&gt;</span> <span class="String">&quot;bool&quot;</span>
                    <span class="Symbol">|</span> <span class="VarId">otherwise</span> <span class="Symbol">-&gt;</span> <span class="VarId">s</span>
  <span class="Keyword">where</span>
      <span class="VarId">smallIntNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;int2&quot;</span><span class="Symbol">,</span> <span class="String">&quot;smallint&quot;</span><span class="Symbol">]</span>
      <span class="VarId">intNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;int4&quot;</span><span class="Symbol">,</span> <span class="String">&quot;integer&quot;</span><span class="Symbol">,</span> <span class="String">&quot;int&quot;</span><span class="Symbol">,</span> <span class="String">&quot;serial&quot;</span><span class="Symbol">]</span>
      <span class="VarId">bigIntNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;int8&quot;</span><span class="Symbol">,</span> <span class="String">&quot;bigint&quot;</span><span class="Symbol">]</span>
      <span class="VarId">numericNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;numeric&quot;</span><span class="Symbol">,</span> <span class="String">&quot;decimal&quot;</span><span class="Symbol">]</span>
      <span class="VarId">float4Names</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;real&quot;</span><span class="Symbol">,</span> <span class="String">&quot;float4&quot;</span><span class="Symbol">]</span>
      <span class="VarId">float8Names</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;double precision&quot;</span><span class="Symbol">,</span> <span class="String">&quot;float&quot;</span><span class="Symbol">]</span>
      <span class="VarId">varcharNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;character varying&quot;</span><span class="Symbol">,</span> <span class="String">&quot;varchar&quot;</span><span class="Symbol">]</span>
      <span class="VarId">charNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;character&quot;</span><span class="Symbol">,</span> <span class="String">&quot;char&quot;</span><span class="Symbol">]</span>
      <span class="VarId">boolNames</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="String">&quot;boolean&quot;</span><span class="Symbol">,</span> <span class="String">&quot;bool&quot;</span><span class="Symbol">]</span>

<span class="Function">canonicalizeTypes</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span>
<span class="Function">canonicalizeTypes</span> <span class="Symbol">=</span>
  <span class="VarId">transformBi</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span>
      <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
        <span class="ConId">ScalarType</span> <span class="VarId">s</span> <span class="Symbol">-&gt;</span> <span class="ConId">ScalarType</span> <span class="Symbol">$</span> <span class="VarId">canonicalizeTypeName</span> <span class="VarId">s</span>
        <span class="VarId">x1</span> <span class="Symbol">-&gt;</span> <span class="VarId">x1</span></pre></div></div></div><p
    >random notes on pg types:</p
    ><pre
    ><code
      ><br
	 />== domains:
the point of domains is you can't put constraints on types, but you
can wrap a type up in a domain and put a constraint on it there.

== literals/selectors

source strings are parsed as unknown type: they can be implicitly cast
to almost any type in the right context.

rows ctors can also be implicitly cast to any composite type matching
the elements (now sure how exactly are they matched? - number of
elements, type compatibility of elements, just by context?).

string literals are not checked for valid syntax currently, but this
will probably change so we can type check string literals statically.
Postgres defers all checking to runtime, because it has to cope with
custom data types. This code will allow adding a grammar checker for
each type so you can optionally check the string lits statically.

== notes on type checking types

=== basic type checking
Currently can lookup type names against a default template1 list of
types, or against the current list in a database (which is read before
processing and sql code).

todo: collect type names from current source file to check against
A lot of the infrastructure to do this is already in place. We also
need to do this for all other definitions, etc.

=== Type aliases

Some types in postgresql have multiple names. I think this is
hardcoded in the pg parser.

For the canonical name in this code, we use the name given in the
postgresql pg_type catalog relvar.

TODO: Change the ast canonical names: where there is a choice, prefer
the sql standard name, where there are multiple sql standard names,
choose the most concise or common one, so the ast will use different
canonical names to postgresql.

planned ast canonical names:
numbers:
int2, int4/integer, int8 -&gt; smallint, int, bigint
numeric, decimal -&gt; numeric
float(1) to float(24), real -&gt; float(24)
float, float(25) to float(53), double precision -&gt; float
serial, serial4 -&gt; int
bigserial, serial8 -&gt; bigint
character varying(n), varchar(n)-&gt; varchar(n)
character(n), char(n) -&gt; char(n)

TODO:

what about PrecTypeName? - need to fix the ast and parser (found out
these are called type modifiers in pg)

also, what can setof be applied to - don't know if it can apply to an
array or setof type

array types have to match an exact array type in the catalog, so we
can't create an arbitrary array of any type. Not sure if this is
handled quite correctly in this code.
</code
      ></pre
    ><hr
     /><p
    >utilities for working with Types</p
    ><p
    >These may indicate that the haskell type system isn't being used very well.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">isArrayType</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Bool</span>
<span class="Function">isArrayType</span> <span class="Symbol">(</span><span class="ConId">ArrayType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isArrayType</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">False</span>

<span class="Function">isDomainType</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Bool</span>
<span class="Function">isDomainType</span> <span class="Symbol">(</span><span class="ConId">DomainType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isDomainType</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">False</span>

<span class="Function">isCompositeType</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Bool</span>
<span class="Function">isCompositeType</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isCompositeType</span> <span class="Symbol">(</span><span class="ConId">NamedCompositeType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isCompositeType</span> <span class="Symbol">(</span><span class="ConId">AnonymousRecordType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isCompositeType</span> <span class="Symbol">(</span><span class="ConId">PgRecord</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">True</span>
<span class="Function">isCompositeType</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">False</span>

<span class="Function">isCompositeOrSetOfCompositeType</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Bool</span>
<span class="Function">isCompositeOrSetOfCompositeType</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">isCompositeType</span> <span class="VarId">a</span>
<span class="Function">isCompositeOrSetOfCompositeType</span> <span class="VarId">a</span> <span class="Symbol">=</span> <span class="VarId">isCompositeType</span> <span class="VarId">a</span>

<span class="Function">unwrapArray</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="ConId">Type</span>
<span class="Function">unwrapArray</span> <span class="Symbol">(</span><span class="ConId">ArrayType</span> <span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">t</span>
<span class="Function">unwrapArray</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;can't get types from non array &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span>

<span class="Function">unwrapSetOfWhenComposite</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="ConId">Type</span>
<span class="Function">unwrapSetOfWhenComposite</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="VarId">a</span><span class="Symbol">@(</span><span class="ConId">CompositeType</span> <span class="VarId">_</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">a</span>
<span class="Function">unwrapSetOfWhenComposite</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;tried to unwrapSetOfWhenComposite on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span>

<span class="Function">unwrapSetOfComposite</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span>  <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
<span class="Function">unwrapSetOfComposite</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">a</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">a</span>
<span class="Function">unwrapSetOfComposite</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;tried to unwrapSetOfComposite on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span>

<span class="Function">unwrapSetOf</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="ConId">Type</span>
<span class="Function">unwrapSetOf</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">a</span>
<span class="Function">unwrapSetOf</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;tried to unwrapSetOf on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span>

<span class="Function">unwrapComposite</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
<span class="Function">unwrapComposite</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">a</span>
<span class="Function">unwrapComposite</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;cannot unwrapComposite on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span>

<span class="Function">consComposite</span> <span class="Symbol">::</span> <span class="Symbol">(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="ConId">Type</span>
<span class="Function">consComposite</span> <span class="VarId">l</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="Symbol">$</span> <span class="ConId">CompositeType</span> <span class="Symbol">(</span><span class="VarId">l</span><span class="Symbol">:</span><span class="VarId">a</span><span class="Symbol">)</span>
<span class="Function">consComposite</span> <span class="VarId">a</span> <span class="VarId">b</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;called consComposite on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="Symbol">(</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">b</span><span class="Symbol">)]</span>

<span class="Function">unwrapRowCtor</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="Symbol">[</span><span class="ConId">Type</span><span class="Symbol">]</span>
<span class="Function">unwrapRowCtor</span> <span class="Symbol">(</span><span class="ConId">AnonymousRecordType</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="VarId">a</span>
<span class="Function">unwrapRowCtor</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">InternalError</span> <span class="Symbol">$</span> <span class="String">&quot;cannot unwrapRowCtor on &quot;</span> <span class="Symbol">++</span> <span class="VarId">show</span> <span class="VarId">x</span><span class="Symbol">]</span></pre></div></div></div><hr
     /><pre
    ><code
      >new plan for types:

The type annotations attached to nodes will be either typecheckfailed 'type'
this will allow chaining type check failed more robustly. Type errors don't change.

the sql type type will be changed so we can track the different
contexts where different sql types can be used, split to use different
sets of types so we can use the haskell type system to enforce these
contexts.

rename type to sqltype, too confusing otherwise
new set of sqltypes: (these aren't in one haskell type anymore)
scalar type - corresponds to sqltypes in pg which aren't one of the
  other types (no easy way to define this)
array type
setof type : can be applied to scalar, domain, ... but not all types
composite types are changed:
namedcomposite string
composite [(string,type)] -&gt; what types can appear in the attribute list?
anonymousrecord [type] -&gt; what types can appear here? -&gt; this
represents a row expression type, which can be returned in select
expressions (but not as a column in a view), and is used in other places
domaintype : what types are allowable as the base type?
pseudo types: these are used for arguments and return values for function prototypes only
any*, record - just means pg infers the return type which will be a composite type (namedcomposite, composite or anonymousrecord), trigger: just a tag, void: just a tag, any*: polymorphic functions, ignore cstring, internal, language handler and opaque.
issue: a variable declaration can be a polymorphic type in a polymorphic function, but we can't use the other pseudo types so need to split these
a variable declared as type record IS NOT the same thing as the pseudo record type, I've finally worked out.
so our plpgsqlrecordtype is plpgsqlrecordtype (Nothing|one of the three composite types)

typechecking polymorphic functions: will have to relax the type
checking to some degree. want to check against each usage of the
polymorphic function in the source, so substitute in the actual types
and check the function.

contexts:
function prototypes: args and return type
function calls: args and return
variable declaration in plpgsql
attribute in a select expression
attribute in a view (less permissive than a select expression), also create table as?
attribute in a table, type (is this the same list as for composite and anonymous records? - can nest anonymous records)
base type for domain
cast expression
insert: targetatts are same set of types as attributes in a table
update: targets can be attr types or anonymous records of attr types for rowset style assign (x,y) = selectexp
assignment statement: type on left same set as type in a for, types in select into, etc?
return statement
return query statement
expressions in a raise statement
expressions in execute, anything else?
types used inside select expression checking:
  selectlist, trefs, groupby, orderby, limit, offset, where, having
expressions:
what can an identifiers type be?
what can the type of an Expression node be?
  scalar: integerlit,floatlit
  stringlit: what can an unknown resolve to (not quite everything)
  booleanlit: scalar
  nulllit: same as stringlit?
  positionalarg: any type that a function arg can have
  cast: any type you can cast to
  identifier: ?
  case, casesimple: any type in the rhs expressions, what are these?
  exists: scalar
  funcall: any type a function return type can have
  inpredicate: scalar
  windowfn: ?
  liftoperator: booleans only?

problem: can't get types using gettypeannotation function and support
different valid combinations of types


new notes
type contexts - these all have different possible types
function return type
function parameter type
OLD &amp; NEW
declared variable
attribute in create table
attribute create type
column in select expression
column in view
column in insert
item in set in update: includes row type with contained types restricted
placeholder
id lookups in local bindings
typenames??

create list of each type for each context
create wrapper types which convert from other types to either
  typeerror type for bad type for context
</code
      ></pre
    ><br
     /><br
     /><br
     /><div class="footer"
    >generated on 01/29/11 20:06:46, hssqlppp-0.3.0</div
    ></body
  ></html
>
