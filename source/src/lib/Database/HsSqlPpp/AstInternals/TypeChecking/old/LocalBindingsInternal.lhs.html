<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >LocalBindingsInternal</title
    ><link href="../../../../../../../../main.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><div class="header"
    ><a href="../../../../../../../../index.txt.html"
      >HsSqlPpp-0.3.0</a
      ></div
    ><br
     /><br
     /><br
     /><p
    >This module contains the code to manage local identifier bindings during the type checking process. This is used for e.g. looking up the types of parameter and variable references in plpgsql functions, and for looking up the types of identifiers in select expressions.</p
    ><p
    >This module exposes the internals of the localbindings datatype for testing.</p
    ><p
    >The lookups to support are a single identifier, or to give a star expansion.</p
    ><p
    >Some notes on lookups all lookups are case insensitive start by searching the head of the lookup update list and working down the code here handles resolving the types of join columns when they are not the same, and the update routine returns error if the join columns are not compatible the code here handles expanding record types so that the components can be looked up</p
    ><p
    >The local bindings is arranged as a stack. To append to this stack, you use the LocalBindingsUpdate type. This is designed to be as easy as possible for clients to use, so as much logic as possible is pushed into the innards of this module, in particular most of the logic for working with joins is in here.</p
    ><p
    >The basic idea of the stack is at each level, there is a list of qualified and unqualified names and types, to look up individual ids. Some of the lookups map to ambiguous identifier errors. Also at each level is a list of star expansions, one for each correlation name in scope, and one for an unqualified star.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-# LANGUAGE ScopedTypeVariables,TupleSections #-}</span>

<span class="Keyword">module</span> <span class="ConId">Database.HsSqlPpp.AstInternals.TypeChecking.LocalBindingsInternal</span>
    <span class="Symbol">(</span>
     <span class="ConId">LocalBindingsUpdate</span><span class="Symbol">(..)</span>
    <span class="Symbol">,</span><span class="ConId">LocalBindings</span><span class="Symbol">(..)</span>
    <span class="Symbol">,</span><span class="ConId">Source</span>
    <span class="Symbol">,</span><span class="ConId">FullId</span>
    <span class="Symbol">,</span><span class="ConId">SimpleId</span>
    <span class="Symbol">,</span><span class="ConId">IDLookup</span>
    <span class="Symbol">,</span><span class="ConId">StarExpand</span>
    <span class="Symbol">,</span><span class="ConId">LocalBindingsLookup</span><span class="Symbol">(..)</span>
    <span class="Symbol">,</span><span class="VarId">emptyBindings</span>
    <span class="Symbol">,</span><span class="VarId">lbUpdate</span>
    <span class="Symbol">,</span><span class="VarId">lbExpandStar</span>
    <span class="Symbol">,</span><span class="VarId">lbLookupID</span>
    <span class="Symbol">,</span><span class="VarId">lbLookupIDInType</span>
    <span class="Comment">--,lbUpdateDot</span>
    <span class="Symbol">,</span><span class="VarId">ppLocalBindings</span>
    <span class="Symbol">,</span><span class="VarId">ppLbls</span>
    <span class="Symbol">)</span> <span class="Keyword">where</span>

<span class="Comment">--import Control.Monad as M</span>
<span class="Keyword">import</span> <span class="ConId">Control.Applicative</span>
<span class="Keyword">import</span> <span class="ConId">Debug.Trace</span>
<span class="Keyword">import</span> <span class="ConId">Data.List</span>
<span class="Keyword">import</span> <span class="ConId">Data.Maybe</span>
<span class="Keyword">import</span> <span class="ConId">Data.Char</span>
<span class="Keyword">import</span> <span class="ConId">Data.Either</span>
<span class="Comment">--import qualified Data.Map as M</span>

<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.AstInternals.TypeType</span>
<span class="Comment">--import Database.HsSqlPpp.Utils.Utils</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.AstInternals.Catalog.CatalogInternal</span>
<span class="Comment">--import Database.HsSqlPpp.AstInternals.TypeChecking.TypeConversion</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.AstInternals.TypeChecking.ErrorUtils</span>
</pre></div></div></div><p
    >The data type to represent a set of local bindings in scope. The list of updates used to create the local bindings is saved for debugging/ information.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">data</span> <span class="ConId">LocalBindings</span> <span class="Symbol">=</span> <span class="ConId">LocalBindings</span> <span class="Symbol">[</span><span class="ConId">LocalBindingsUpdate</span><span class="Symbol">]</span>
                                   <span class="Symbol">[</span><span class="ConId">LocalBindingsLookup</span><span class="Symbol">]</span>
                     <span class="Keyword">deriving</span> <span class="ConId">Show</span></pre></div></div></div><p
    >Each layer of the local bindings stack is a map from (correlation name, id name) to source,correlation name, id name, type tuple, or a type error, used e.g. to represent ambigious ids, etc.; and a map from correlation name to a list of these tuples to handle star expansions.</p
    ><p
    >Missing correlation names are represented by an empty string for the correlation name.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">type</span> <span class="ConId">Source</span> <span class="Symbol">=</span> <span class="ConId">String</span>

<span class="Keyword">type</span> <span class="ConId">FullId</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="ConId">Source</span><span class="Symbol">,[</span><span class="ConId">String</span><span class="Symbol">],</span><span class="ConId">Type</span><span class="Symbol">)</span> <span class="Comment">-- source,fully qualified name components,type</span>
<span class="Keyword">type</span> <span class="ConId">SimpleId</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)</span>
<span class="Keyword">type</span> <span class="ConId">IDLookup</span> <span class="Symbol">=</span> <span class="Symbol">([</span><span class="ConId">String</span><span class="Symbol">],</span> <span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)</span>
<span class="Keyword">type</span> <span class="ConId">StarExpand</span> <span class="Symbol">=</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">]</span> <span class="Comment">--the order of the [FullId] part is important</span>

<span class="Keyword">data</span> <span class="ConId">LocalBindingsLookup</span> <span class="Symbol">=</span> <span class="ConId">LocalBindingsLookup</span>
                               <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span>
                               <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">StarExpand</span><span class="Symbol">)]</span>
                           <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span><span class="ConId">Show</span><span class="Symbol">)</span></pre></div></div></div><p
    >This is the local bindings update that users of this module use.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">data</span> <span class="ConId">LocalBindingsUpdate</span> <span class="Symbol">=</span> <span class="ConId">LBIds</span> <span class="Symbol">{</span><span class="VarId">source</span> <span class="Symbol">::</span> <span class="ConId">Source</span>
                                 <span class="Symbol">,</span><span class="VarId">correlationName</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">String</span>
                                 <span class="Symbol">,</span><span class="VarId">lbids</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">SimpleId</span><span class="Symbol">]}</span>
                         <span class="Symbol">|</span> <span class="ConId">LBTref</span> <span class="Symbol">{</span><span class="VarId">source</span> <span class="Symbol">::</span> <span class="ConId">Source</span>
                                  <span class="Symbol">,</span><span class="VarId">talias</span> <span class="Symbol">::</span> <span class="ConId">String</span>
                                  <span class="Symbol">,</span><span class="VarId">lbids</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">SimpleId</span><span class="Symbol">]</span>
                                  <span class="Symbol">,</span><span class="VarId">lbsysids</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">SimpleId</span><span class="Symbol">]}</span>
                         <span class="Symbol">|</span> <span class="ConId">LBJoinTref</span> <span class="Symbol">{</span><span class="VarId">source</span> <span class="Symbol">::</span> <span class="ConId">Source</span>
                                      <span class="Symbol">,</span><span class="VarId">jtref1</span> <span class="Symbol">::</span> <span class="ConId">LocalBindingsUpdate</span>
                                      <span class="Symbol">,</span><span class="VarId">jtref2</span> <span class="Symbol">::</span> <span class="ConId">LocalBindingsUpdate</span>
                                      <span class="Symbol">,</span><span class="VarId">joinIds</span> <span class="Symbol">::</span> <span class="ConId">Either</span> <span class="Symbol">()</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span> <span class="Comment">-- left () represents natural join</span>
                                                           <span class="Comment">-- right [] represents no join ids</span>
                                      <span class="Symbol">,</span><span class="VarId">jalias</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">String</span><span class="Symbol">}</span>
                           <span class="Keyword">deriving</span> <span class="ConId">Show</span>

<span class="Function">emptyBindings</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span>
<span class="Function">emptyBindings</span> <span class="Symbol">=</span> <span class="ConId">LocalBindings</span> <span class="Symbol">[]</span> <span class="Symbol">[]</span></pre></div></div></div><p
    >================================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">ppLocalBindings</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">ppLocalBindings</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">lbus</span> <span class="VarId">lbls</span><span class="Symbol">)</span> <span class="Symbol">=</span>
  <span class="String">&quot;LocalBindings\n&quot;</span> <span class="Symbol">++</span> <span class="VarId">doList</span> <span class="VarId">show</span> <span class="VarId">lbus</span> <span class="Symbol">++</span> <span class="VarId">doList</span> <span class="VarId">ppLbls</span> <span class="VarId">lbls</span>

<span class="Function">ppLbls</span> <span class="Symbol">::</span> <span class="ConId">LocalBindingsLookup</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">ppLbls</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">is</span> <span class="VarId">ss</span><span class="Symbol">)</span> <span class="Symbol">=</span>
      <span class="String">&quot;LocalBindingsLookup\n&quot;</span> <span class="Symbol">++</span> <span class="VarId">doList</span> <span class="VarId">show</span> <span class="VarId">is</span> <span class="Symbol">++</span> <span class="VarId">doList</span> <span class="VarId">show</span> <span class="VarId">ss</span>

<span class="Function">doList</span> <span class="Symbol">::</span> <span class="Symbol">(</span><span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="VarId">a</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">doList</span> <span class="VarId">m</span> <span class="VarId">l</span> <span class="Symbol">=</span> <span class="String">&quot;[\n&quot;</span> <span class="Symbol">++</span> <span class="VarId">intercalate</span> <span class="String">&quot;\n,&quot;</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">m</span> <span class="VarId">l</span><span class="Symbol">)</span> <span class="Symbol">++</span> <span class="String">&quot;\n]\n&quot;</span></pre></div></div></div><p
    >================================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbUpdate</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindingsUpdate</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">LocalBindings</span>
<span class="Function">lbUpdate</span> <span class="VarId">cat</span> <span class="VarId">u1</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">us</span> <span class="VarId">s</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="Symbol">(</span><span class="VarId">ids</span><span class="Symbol">,</span><span class="VarId">se</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">updateStuff</span> <span class="VarId">cat</span> <span class="VarId">u1</span>
  <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">LocalBindings</span> <span class="Symbol">(</span><span class="VarId">u1</span> <span class="Symbol">:</span> <span class="VarId">us</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">ids</span> <span class="VarId">se</span> <span class="Symbol">:</span> <span class="VarId">s</span><span class="Symbol">)</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">updateStuff</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindingsUpdate</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">([</span><span class="ConId">IDLookup</span><span class="Symbol">],[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">StarExpand</span><span class="Symbol">)])</span></pre></div></div></div><p
    >LBIds doesn't support any star expansion, and doesn't support accessing the whole set of ids as a composite via cn</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">updateStuff</span> <span class="VarId">_</span> <span class="Symbol">(</span><span class="ConId">LBIds</span> <span class="VarId">src</span> <span class="VarId">cn</span> <span class="VarId">ids</span><span class="Symbol">)</span> <span class="Symbol">=</span>
    <span class="VarId">return</span> <span class="Symbol">(</span><span class="VarId">unQuals</span> <span class="Symbol">++</span> <span class="VarId">quals</span><span class="Symbol">,</span> <span class="Symbol">[])</span>
    <span class="Keyword">where</span>
      <span class="VarId">unQuals</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">([</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,</span><span class="VarId">maybe</span> <span class="Symbol">[</span><span class="VarId">n</span><span class="Symbol">]</span> <span class="Symbol">(:</span> <span class="Symbol">[</span><span class="VarId">n</span><span class="Symbol">])</span> <span class="VarId">cn</span><span class="Symbol">,</span> <span class="VarId">t</span><span class="Symbol">)))</span> <span class="VarId">ids</span>
      <span class="VarId">quals</span> <span class="Symbol">=</span> <span class="VarId">maybe</span> <span class="Symbol">[]</span> <span class="Symbol">(\</span><span class="VarId">cn'</span> <span class="Symbol">-&gt;</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">([</span><span class="VarId">cn'</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,[</span><span class="VarId">cn'</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="VarId">t</span><span class="Symbol">)))</span> <span class="VarId">ids</span><span class="Symbol">)</span> <span class="VarId">cn</span></pre></div></div></div><p
    >tref - used for a non join table reference, supports accessing public fields under the alias name as a composite, and also supports system id lookups. The star expansions are all the non system ids qualified and unqualified</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">updateStuff</span> <span class="VarId">_</span> <span class="Symbol">(</span><span class="ConId">LBTref</span> <span class="VarId">src</span> <span class="VarId">al</span> <span class="VarId">ids</span> <span class="VarId">sids</span><span class="Symbol">)</span> <span class="Symbol">=</span>
    <span class="Comment">-- comp has to come after unquals because an unqualified reference which could refer</span>
    <span class="Comment">-- to a column or the composite resolves as the column</span>
    <span class="VarId">return</span> <span class="Symbol">(</span><span class="VarId">unQuals</span> <span class="Symbol">++</span> <span class="VarId">quals</span> <span class="Symbol">++</span> <span class="Symbol">[</span><span class="VarId">comp</span><span class="Symbol">]</span>
           <span class="Symbol">,[(</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="VarId">pids</span><span class="Symbol">),(</span><span class="VarId">al</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="VarId">pids</span><span class="Symbol">)])</span>
    <span class="Keyword">where</span>
      <span class="VarId">allIds</span> <span class="Symbol">=</span> <span class="VarId">ids</span> <span class="Symbol">++</span> <span class="VarId">sids</span>
      <span class="VarId">unQuals</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">([</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,[</span><span class="VarId">al</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="VarId">t</span><span class="Symbol">)))</span> <span class="VarId">allIds</span>
      <span class="VarId">quals</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">([</span><span class="VarId">al</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,[</span><span class="VarId">al</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span> <span class="VarId">t</span><span class="Symbol">)))</span> <span class="VarId">allIds</span>
      <span class="VarId">comp</span> <span class="Symbol">=</span> <span class="Symbol">([</span><span class="VarId">al</span><span class="Symbol">],</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,</span> <span class="Symbol">[</span><span class="VarId">al</span><span class="Symbol">],</span> <span class="ConId">CompositeType</span> <span class="VarId">ids</span><span class="Symbol">))</span>
      <span class="VarId">pids</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,[</span><span class="VarId">al</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">],</span><span class="VarId">t</span><span class="Symbol">))</span> <span class="VarId">ids</span></pre></div></div></div><p
    >LBJoinTref {source :: Source ,jtref1 :: LocalBindingsUpdate ,jtref2 :: LocalBindingsUpdate ,joinIds :: Either () [String] -- left () represents natural join -- right [] represents no join ids ,jalias :: Maybe String}</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">updateStuff</span> <span class="VarId">cat</span> <span class="Symbol">(</span><span class="ConId">LBJoinTref</span> <span class="VarId">_src</span> <span class="VarId">u1</span> <span class="VarId">u2</span> <span class="VarId">jnames'</span> <span class="VarId">_al</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span></pre></div></div></div><p
    >How to get the lbs for a join:</p
    ><p
    >First get the info for the two sub trefs:</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">  <span class="Symbol">(</span><span class="VarId">ids1</span><span class="Symbol">,</span><span class="VarId">se1</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">updateStuff</span> <span class="VarId">cat</span> <span class="VarId">u1</span>
  <span class="Symbol">(</span><span class="VarId">ids2</span><span class="Symbol">,</span><span class="VarId">se2</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">updateStuff</span> <span class="VarId">cat</span> <span class="VarId">u2</span></pre></div></div></div><p
    >split these apart so we have the unqualified lookups and star expands separately</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">  <span class="Keyword">let</span> <span class="Symbol">(</span><span class="VarId">uids1</span><span class="Symbol">,</span><span class="VarId">qids1</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">splitLkps</span> <span class="VarId">ids1</span>
      <span class="Symbol">(</span><span class="VarId">uids2</span><span class="Symbol">,</span><span class="VarId">qids2</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">splitLkps</span> <span class="VarId">ids2</span></pre></div></div></div><p
    >We need some information: the names and types of the join ids, and the names of any remaining ambiguous identifiers:</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">  <span class="Keyword">let</span> <span class="VarId">jnames</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span>
      <span class="VarId">jnames</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">jnames'</span> <span class="Keyword">of</span>
                         <span class="ConId">Right</span> <span class="VarId">ns</span> <span class="Symbol">-&gt;</span> <span class="VarId">ns</span>
                         <span class="ConId">Left</span> <span class="Symbol">()</span> <span class="Symbol">-&gt;</span> <span class="VarId">intersect</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">fst</span> <span class="VarId">uids1</span><span class="Symbol">)</span>
                                              <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">fst</span> <span class="VarId">uids2</span><span class="Symbol">)</span>
  <span class="Comment">--todo: resolve these properly</span>
  <span class="Keyword">let</span> <span class="VarId">jids</span> <span class="Symbol">=</span> <span class="VarId">flip</span> <span class="VarId">map</span> <span class="VarId">jnames</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">i</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">i</span><span class="Symbol">,</span><span class="VarId">fromJust</span> <span class="Symbol">$</span> <span class="VarId">lookup</span> <span class="Symbol">[</span><span class="VarId">i</span><span class="Symbol">]</span> <span class="VarId">ids1</span><span class="Symbol">)</span></pre></div></div></div><p
    >First: get the names of the join ids: this is the explicit list in the case of a using join, or the commonly named fields in a natural join. We get the commonly named fields from the unqualified star expansions so we don't include system attributes in a natural join.</p
    ><p
    >Then check: make sure explicit join id list is in both trefs, and resolve the types of the join ids.</p
    ><p
    >If there is no alias:</p
    ><p
    >work out the lookups: the qualified lookups stay the same (doesn't properly deal with the same correlation names coming from 2 trefs at the moment).</p
    ><p
    >get the list of duplicate ids: uses the same code as getting the natural join id list, - there will be none if this is a natural join. Otherwise, get the list of common ids and remove any using ids from this list. TODO?: system attributes can't be referenced through a join unqualified?</p
    ><p
    >The unqualified lookups: start with the join ids and types, then add all the ids from each subtref except the ones which match the duplicate ids. Add these dups which now lookup to left ambiguous reference.</p
    ><p
    >work out the star expansion: the qualified star expansions stay the same</p
    ><p
    >for the unqualified star expansion: similar to lookups. Start with the join ids, but then add all the non join ids from each table - so we might have more than one column with the same name.</p
    ><p
    >If there is an alias:</p
    ><p
    >do the same as above for the unqualified ids/starexpand, add these again under the given alias, and don't pass through qualified lookups or star expands.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">  <span class="Comment">{-let plainIds1 = pl ids1</span>
<span class="Comment">      plainIds2 = pl ids2</span>
<span class="Comment">  let jnames :: [String]</span>
<span class="Comment">      jnames = case jids of</span>
<span class="Comment">                         Right ns -&gt; ns</span>
<span class="Comment">                         Left () -&gt; intersect (map fst plainIds1) (map fst plainIds2)</span>
<span class="Comment">  -- make the lookups</span>
<span class="Comment">      isJ :: IDLookup -&gt; Bool</span>
<span class="Comment">      isJ (ii,_) = case ii of</span>
<span class="Comment">                       [i] | i `elem` jnames -&gt; True</span>
<span class="Comment">                       _ -&gt; False</span>
<span class="Comment">      nj :: [IDLookup] -&gt; [IDLookup]</span>
<span class="Comment">      nj = filter (not . isJ)</span>
<span class="Comment">      joinLkps = filter isJ ids1</span>
<span class="Comment">      nonJoinLkps1 = nj ids1</span>
<span class="Comment">      nonJoinLkps2 = nj ids2-}</span>
  <span class="Comment">{-let jids1 :: [(String,E FullId)]</span>
<span class="Comment">      jids1 = flip map jnames $ \i -&gt; (i,fromJust $ lookup i ids1)</span>
<span class="Comment">      rj :: [(String,E FullId)] -&gt; [(String,E FullId)]</span>
<span class="Comment">      rj = filter $ \e -&gt; fst e `notElem` jnames</span>
<span class="Comment">      ids :: [(String,E FullId)]</span>
<span class="Comment">      ids = jids1 ++ rj ids1 ++ rj ids2-}</span>
  <span class="Comment">--make the star expansion</span>
  <span class="Comment">--se1' &lt;- se1</span>
  <span class="Comment">--se2' &lt;- se2</span>
  <span class="Comment">{-let (us1',qs1) = splitSe se1'</span>
<span class="Comment">      (us2',qs2) = splitSe se2'</span>
<span class="Comment">  us1 &lt;- us1'</span>
<span class="Comment">  us2 &lt;- us2'-}</span>
  <span class="Comment">{-    rj1 :: [FullId] -&gt; [FullId]</span>
<span class="Comment">      rj1 = filter $ \(_,n,_t) -&gt; last n `notElem` jnames</span>
<span class="Comment">      se = map snd jids1 ++ map return (rj1 se1) ++ map return (rj1 se2)</span>
<span class="Comment">  return (ids, sequence se)-}</span>
  <span class="Comment">--let x = joinLkps ++ nonJoinLkps1 ++ nonJoinLkps2</span>
  <span class="Comment">--trace (&quot;join stuff: &quot; ++ doList show x) $ return ()</span>
  <span class="VarId">return</span> <span class="Symbol">(</span><span class="VarId">ids1</span> <span class="Symbol">++</span> <span class="VarId">ids1</span><span class="Symbol">,</span> <span class="VarId">se1</span> <span class="Symbol">++</span> <span class="VarId">se2</span><span class="Symbol">)</span> <span class="Comment">--(joinLkps ++ nonJoinLkps1 ++ nonJoinLkps2, (&quot;&quot;, Right (us1 ++ us2)) : qs1 ++ qs2)</span>
  <span class="Keyword">where</span>
    <span class="Comment">{-splitSe :: [(String,StarExpand)] -&gt; (StarExpand,[(String,StarExpand)])</span>
<span class="Comment">    splitSe se = (uq, nuq)</span>
<span class="Comment">                 where</span>
<span class="Comment">                   uq = maybe [] snd $ find isUq se</span>
<span class="Comment">                   nuq = filter (not . isUq) se</span>
<span class="Comment">                   isUq (Right (a,_)) = a == &quot;&quot;-}</span>
    <span class="VarId">splitLkps</span> <span class="Symbol">::</span> <span class="Symbol">[([</span><span class="ConId">String</span><span class="Symbol">],</span> <span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)]</span>
              <span class="Symbol">-&gt;</span> <span class="Symbol">([(</span><span class="ConId">String</span><span class="Symbol">,</span> <span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)],[([</span><span class="ConId">String</span><span class="Symbol">],</span> <span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)])</span>
    <span class="VarId">splitLkps</span> <span class="Symbol">=</span> <span class="VarId">partitionEithers</span> <span class="Symbol">.</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">x</span> <span class="Symbol">-&gt;</span> <span class="Keyword">case</span> <span class="VarId">x</span> <span class="Keyword">of</span>
                                                      <span class="Symbol">([</span><span class="VarId">n</span><span class="Symbol">],</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="ConId">Left</span> <span class="Symbol">(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span>
                                                      <span class="VarId">z</span> <span class="Symbol">-&gt;</span> <span class="ConId">Right</span> <span class="VarId">z</span><span class="Symbol">)</span></pre></div></div></div><p
    >================================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbExpandStar</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">]</span>
<span class="Function">lbExpandStar</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">_</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">_</span> <span class="VarId">x</span> <span class="Symbol">:</span> <span class="VarId">_</span><span class="Symbol">))</span> <span class="VarId">c</span> <span class="Symbol">=</span>
  <span class="VarId">maybe</span> <span class="Symbol">(</span><span class="Keyword">case</span> <span class="VarId">c</span> <span class="Keyword">of</span>
           <span class="String">&quot;&quot;</span> <span class="Symbol">-&gt;</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">BadStarExpand</span><span class="Symbol">]</span>
           <span class="VarId">y</span> <span class="Symbol">-&gt;</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">UnrecognisedCorrelationName</span> <span class="VarId">y</span><span class="Symbol">])</span>
           <span class="VarId">id</span> <span class="Symbol">$</span> <span class="VarId">lookup</span> <span class="VarId">c</span> <span class="VarId">x</span>
<span class="Function">lbExpandStar</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">BadStarExpand</span><span class="Symbol">]</span></pre></div></div></div><p
    >================================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbLookupID</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">FullId</span>
<span class="Function">lbLookupID</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">_</span> <span class="VarId">lbl</span><span class="Symbol">)</span> <span class="VarId">i</span> <span class="Symbol">=</span>
    <span class="Keyword">let</span> <span class="VarId">ls</span> <span class="Symbol">::</span> <span class="Symbol">[[([</span><span class="ConId">String</span><span class="Symbol">],</span><span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)]]</span>
        <span class="VarId">ls</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">getLbIdl</span> <span class="VarId">lbl</span>
    <span class="Keyword">in</span> <span class="VarId">lkp1</span> <span class="VarId">ls</span> <span class="Symbol">$</span> <span class="VarId">map</span> <span class="VarId">mtl</span> <span class="VarId">i</span>
    <span class="Keyword">where</span>
      <span class="VarId">lkp1</span> <span class="Symbol">::</span> <span class="Symbol">[[</span><span class="ConId">IDLookup</span><span class="Symbol">]]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">FullId</span>
      <span class="VarId">lkp1</span> <span class="Symbol">(</span><span class="VarId">l</span><span class="Symbol">:</span><span class="VarId">ls</span><span class="Symbol">)</span> <span class="VarId">i1</span> <span class="Symbol">=</span> <span class="VarId">fromMaybe</span> <span class="Symbol">(</span><span class="VarId">lkp1</span> <span class="VarId">ls</span> <span class="VarId">i1</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">lookup</span> <span class="VarId">i1</span> <span class="VarId">l</span><span class="Symbol">)</span>
      <span class="VarId">lkp1</span> <span class="Symbol">[]</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="Keyword">if</span> <span class="VarId">corMatch</span>
                  <span class="Keyword">then</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">UnrecognisedIdentifier</span> <span class="Symbol">(</span><span class="VarId">intercalate</span> <span class="String">&quot;.&quot;</span> <span class="VarId">i</span><span class="Symbol">)]</span>
                  <span class="Keyword">else</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">UnrecognisedCorrelationName</span> <span class="Symbol">(</span><span class="VarId">head</span> <span class="VarId">i</span><span class="Symbol">)]</span>
      <span class="VarId">getLbIdl</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">x</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">x</span>
      <span class="VarId">corMatch</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">i</span> <span class="Keyword">of</span>
                   <span class="Symbol">[</span><span class="VarId">q</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="VarId">q</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">cors</span>
                   <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="ConId">True</span>
      <span class="VarId">cors</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span>
      <span class="VarId">cors</span> <span class="Symbol">=</span> <span class="Keyword">let</span> <span class="VarId">ls</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">getLbIdl</span> <span class="VarId">lbl</span>
             <span class="Keyword">in</span> <span class="VarId">catMaybes</span> <span class="Symbol">$</span> <span class="VarId">concatMap</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">getQ</span><span class="Symbol">)</span> <span class="VarId">ls</span>
      <span class="VarId">getQ</span> <span class="Symbol">::</span> <span class="Symbol">([</span><span class="ConId">String</span><span class="Symbol">],</span> <span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="ConId">Maybe</span> <span class="ConId">String</span>
      <span class="VarId">getQ</span> <span class="Symbol">([</span><span class="VarId">q</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">],</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Just</span> <span class="VarId">q</span>
      <span class="VarId">getQ</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">Nothing</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbLookupIDInType</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">FullId</span>
<span class="Function">lbLookupIDInType</span> <span class="VarId">cat</span> <span class="VarId">_</span> <span class="VarId">ty</span> <span class="VarId">i</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="VarId">t</span> <span class="Symbol">&lt;-</span> <span class="VarId">lmt</span> <span class="Symbol">$</span> <span class="VarId">getNamedCompositeTypes</span> <span class="VarId">ty</span>
  <span class="VarId">maybe</span> <span class="Symbol">(</span><span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">UnrecognisedIdentifier</span> <span class="VarId">i</span><span class="Symbol">])</span> <span class="Symbol">(</span><span class="VarId">fmap</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="String">&quot;&quot;</span><span class="Symbol">,[</span><span class="VarId">i</span><span class="Symbol">],))</span> <span class="Symbol">$</span> <span class="VarId">lookup</span> <span class="VarId">i</span> <span class="VarId">t</span>
 <span class="Keyword">where</span>
   <span class="VarId">getNamedCompositeTypes</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">Maybe</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
   <span class="VarId">getNamedCompositeTypes</span> <span class="Symbol">(</span><span class="ConId">NamedCompositeType</span> <span class="VarId">n</span><span class="Symbol">)</span> <span class="Symbol">=</span>
        <span class="ConId">Just</span> <span class="Symbol">$</span> <span class="VarId">either</span> <span class="Symbol">(</span><span class="VarId">const</span> <span class="Symbol">[])</span> <span class="VarId">id</span> <span class="Symbol">$</span> <span class="VarId">catCompositePublicAttrs</span> <span class="VarId">cat</span> <span class="Symbol">[]</span> <span class="VarId">n</span>
   <span class="VarId">getNamedCompositeTypes</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Just</span> <span class="VarId">t</span>
   <span class="VarId">getNamedCompositeTypes</span> <span class="Symbol">(</span><span class="ConId">PgRecord</span> <span class="Symbol">(</span><span class="ConId">Just</span> <span class="VarId">t</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="VarId">getNamedCompositeTypes</span> <span class="VarId">t</span>
   <span class="VarId">getNamedCompositeTypes</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">Nothing</span></pre></div></div></div><p
    >================================================================================</p
    ><blockquote
    ><p
      >lbUpdateDot :: Catalog -&gt; String -&gt; LocalBindings -&gt; E LocalBindings lbUpdateDot cat i lb = do (<em
	>,</em
	>,c) &lt;- lbLookupID lb i f &lt;- lmt $ expandComposite cat True c lbUpdate cat (LBIds &quot;dot qual&quot; Nothing f) emptyBindings</p
      ></blockquote
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">    <span class="Comment">{-f &lt;- lmt $ expandComposite cat True c</span>
<span class="Comment">    let u1 = (LBIds &quot;dot qual&quot; Nothing f)</span>
<span class="Comment">    (ids,_) &lt;- updateStuff cat u1</span>
<span class="Comment">    pf &lt;- lmt $ expandComposite cat False c</span>
<span class="Comment">    let se = Right $ map (\(n,t) -&gt; (&quot;dot qual&quot;, [i,n], t)) pf</span>
<span class="Comment">    return $ LocalBindings [u1] [LocalBindingsLookup ids se]-}</span></pre></div></div></div><p
    >(Source, [String], Type)' against inferred type `(String, Type)'</p
    ><blockquote
    ><p
      >expandComposite :: Catalog -&gt; Bool -&gt; Type -&gt; Maybe [(String,Type)] expandComposite cat b (SetOfType t) = expandComposite cat b t expandComposite cat b (PgRecord (Just t)) = expandComposite cat b t expandComposite _ _ (CompositeType fs) = Just fs expandComposite cat b (NamedCompositeType n) = etmt $ (if b then catCompositeAttrs else catCompositePublicAttrs) cat [] n expandComposite _ _ _ = Nothing</p
      ></blockquote
    ><p
    >================================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">mtl</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">mtl</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">toLower</span></pre></div></div></div><p
    >wrapper for the proper lookupid function, this is for backwards compatibility with the old lookup code</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-lbLookupID :: LocalBindings</span>
<span class="Comment">           -&gt; String -- identifier name</span>
<span class="Comment">           -&gt; E Type</span>
<span class="Comment">lbLookupID lb ci = let (cor,i) = splitIdentifier ci</span>
<span class="Comment">                   in fmap extractType $ lbLookupID1 lb cor i</span>
<span class="Comment">                   where</span>
<span class="Comment">                     extractType (_,_,_,t) = t</span>
<span class="Comment">                     splitIdentifier s = let (a,b) = span (/= '.') s</span>
<span class="Comment">                                         in if b == &quot;&quot;</span>
<span class="Comment">                                            then (&quot;&quot;, a)</span>
<span class="Comment">                                            else (a,tail b)</span>

<span class="Comment">lbLookupID1 :: LocalBindings</span>
<span class="Comment">           -&gt; String -- correlation name</span>
<span class="Comment">           -&gt; String -- identifier name</span>
<span class="Comment">           -&gt; E FullId -- type error or source, corr, type</span>
<span class="Comment">lbLookupID1 (LocalBindings _ lkps) cor' i' =</span>
<span class="Comment">  --trace (&quot;lookup: &quot; ++ showID cor' i'</span>
<span class="Comment">  --       ++ &quot;in &quot; ++ concatMap ppLbls lkps) $</span>
<span class="Comment">  -- hack for triggers</span>
<span class="Comment">  case cor of</span>
<span class="Comment">    &quot;new&quot; | isTrigRec -&gt; Right (&quot;&quot;, &quot;new&quot;, i, UnknownType)</span>
<span class="Comment">    &quot;old&quot; | isTrigRec -&gt; Right (&quot;&quot;, &quot;old&quot;, i, UnknownType)</span>
<span class="Comment">    _ -&gt; lkId lkps</span>
<span class="Comment">  where</span>
<span class="Comment">    isTrigRec = case lbLookupID1 (LocalBindings undefined lkps) &quot;&quot; cor of</span>
<span class="Comment">                  Right (_,_,_,Pseudo TriggerRecord) -&gt; True</span>
<span class="Comment">                  _ -&gt; False</span>
<span class="Comment">    cor = mtl cor'</span>
<span class="Comment">    i = mtl i'</span>
<span class="Comment">    lkId ((LocalBindingsLookup idmap _):ls) =</span>
<span class="Comment">      case lookup (cor,i) idmap of</span>
<span class="Comment">        Just s -&gt; s</span>
<span class="Comment">        Nothing -&gt; if cor /= &quot;&quot; &amp;&amp; any ((==cor) . fst . fst) idmap</span>
<span class="Comment">                   then Left [UnrecognisedIdentifier $ showID cor i']</span>
<span class="Comment">                   else lkId ls</span>
<span class="Comment">    lkId [] = if cor' == &quot;&quot; --todo: need to throw unrecognised identifier, if the correlation name isn't &quot;&quot;, a id isn't found, and there are other ids with that correlation name</span>
<span class="Comment">              then Left [UnrecognisedIdentifier $ showID cor i']</span>
<span class="Comment">              else Left [UnrecognisedCorrelationName cor']</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >wrapped for the proper expand star routine, for compatibility with the old implementation of local bindings</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbExpandStar</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">SimpleId</span><span class="Symbol">]</span>
<span class="Function">lbExpandStar</span> <span class="VarId">lb</span> <span class="VarId">cor</span> <span class="Symbol">=</span>
  <span class="VarId">fmap</span> <span class="VarId">stripAll</span> <span class="Symbol">$</span> <span class="VarId">lbExpandStar1</span> <span class="VarId">lb</span> <span class="VarId">cor</span>
  <span class="Keyword">where</span>
    <span class="VarId">strip</span> <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span>
    <span class="VarId">stripAll</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">strip</span>

<span class="Function">lbExpandStar1</span> <span class="Symbol">::</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">]</span>
<span class="Function">lbExpandStar1</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">_</span> <span class="VarId">lkps</span><span class="Symbol">)</span> <span class="VarId">cor'</span> <span class="Symbol">=</span>
  <span class="VarId">exSt</span> <span class="VarId">lkps</span>
  <span class="Keyword">where</span>
    <span class="VarId">cor</span> <span class="Symbol">=</span> <span class="VarId">mtl</span> <span class="VarId">cor'</span>
    <span class="VarId">exSt</span> <span class="Symbol">((</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">_</span> <span class="VarId">lst</span><span class="Symbol">):</span><span class="VarId">ls</span><span class="Symbol">)</span> <span class="Symbol">=</span>
        <span class="Keyword">case</span> <span class="VarId">lookup</span> <span class="VarId">cor</span> <span class="VarId">lst</span> <span class="Keyword">of</span>
          <span class="ConId">Just</span> <span class="VarId">s</span> <span class="Symbol">-&gt;</span> <span class="VarId">s</span>
          <span class="ConId">Nothing</span> <span class="Symbol">-&gt;</span> <span class="VarId">exSt</span> <span class="VarId">ls</span>
    <span class="VarId">exSt</span> <span class="Symbol">[]</span> <span class="Symbol">=</span> <span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">UnrecognisedCorrelationName</span> <span class="VarId">cor</span><span class="Symbol">]</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >This is where constructing the local bindings lookup stacks is done</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lbUpdate</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindingsUpdate</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindings</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">LocalBindings</span>
<span class="Function">lbUpdate</span> <span class="VarId">cat</span> <span class="VarId">lbu'</span> <span class="Symbol">(</span><span class="ConId">LocalBindings</span> <span class="VarId">lbus</span> <span class="VarId">lkps</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
   <span class="VarId">lbl</span> <span class="Symbol">&lt;-</span> <span class="VarId">makeStack</span> <span class="VarId">cat</span> <span class="VarId">lbu</span>
   <span class="VarId">lbl1</span> <span class="Symbol">&lt;-</span> <span class="VarId">expandComposites</span> <span class="VarId">cat</span> <span class="VarId">lbl</span>
   <span class="Comment">--trace (&quot;update: &quot; ++ ppLbls lbl1) $ return ()</span>
   <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">LocalBindings</span> <span class="Symbol">(</span><span class="VarId">lbu'</span><span class="Symbol">:</span><span class="VarId">lbus</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">lbl1</span><span class="Symbol">:</span><span class="VarId">lkps</span><span class="Symbol">)</span>
   <span class="Keyword">where</span>
     <span class="VarId">lbu</span> <span class="Symbol">=</span> <span class="VarId">lowerise</span> <span class="VarId">lbu'</span>
     <span class="Comment">-- make correlation names and id names case insensitive</span>
     <span class="Comment">-- by making them all lowercase</span>
     <span class="VarId">lowerise</span> <span class="Symbol">(</span><span class="ConId">LBIds</span> <span class="VarId">src</span> <span class="VarId">ids</span><span class="Symbol">)</span> <span class="Symbol">=</span>
       <span class="ConId">LBIds</span> <span class="VarId">src</span> <span class="Symbol">(</span><span class="VarId">mtll</span> <span class="VarId">ids</span><span class="Symbol">)</span>
     <span class="VarId">lowerise</span> <span class="Symbol">(</span><span class="ConId">LBJoinIds</span> <span class="VarId">t1</span> <span class="VarId">t2</span> <span class="VarId">ji</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span>
       <span class="ConId">LBJoinIds</span> <span class="Symbol">(</span><span class="VarId">lowerise</span> <span class="VarId">t1</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">lowerise</span> <span class="VarId">t2</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">fmap</span> <span class="VarId">mtll1</span> <span class="VarId">ji</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">mtl</span> <span class="VarId">a</span><span class="Symbol">)</span>
     <span class="VarId">lowerise</span> <span class="Symbol">(</span><span class="ConId">LBParallel</span> <span class="VarId">lbu1</span> <span class="VarId">lbu2</span><span class="Symbol">)</span> <span class="Symbol">=</span>
       <span class="ConId">LBParallel</span> <span class="Symbol">(</span><span class="VarId">lowerise</span> <span class="VarId">lbu1</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">lowerise</span> <span class="VarId">lbu2</span><span class="Symbol">)</span>
     <span class="VarId">mtll</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">mtl</span> <span class="VarId">n</span><span class="Symbol">,</span> <span class="VarId">t</span><span class="Symbol">))</span>
     <span class="VarId">mtll1</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\</span><span class="VarId">l</span> <span class="Symbol">-&gt;</span> <span class="VarId">mtl</span> <span class="VarId">l</span><span class="Symbol">)</span>

<span class="Function">makeStack</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindingsUpdate</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">LocalBindingsLookup</span>
<span class="Function">makeStack</span> <span class="VarId">_</span> <span class="Symbol">(</span><span class="ConId">LBIds</span> <span class="VarId">src</span> <span class="VarId">ids</span><span class="Symbol">)</span> <span class="Symbol">=</span>
  <span class="ConId">Right</span> <span class="Symbol">$</span> <span class="ConId">LocalBindingsLookup</span> <span class="VarId">doIds</span> <span class="VarId">doStar</span>
  <span class="Keyword">where</span>
    <span class="VarId">doIds</span> <span class="Symbol">::</span> <span class="Symbol">[((</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">String</span><span class="Symbol">)</span>
              <span class="Symbol">,</span><span class="ConId">E</span> <span class="ConId">FullId</span><span class="Symbol">)]</span>
    <span class="VarId">doIds</span> <span class="Symbol">=</span> <span class="Comment">-- add unqualified if cor isn't empty string</span>
            <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">makeLookup</span> <span class="String">&quot;&quot;</span><span class="Symbol">)</span>
                   <span class="Symbol">(</span><span class="Keyword">case</span> <span class="VarId">cor</span> <span class="Keyword">of</span>
                            <span class="String">&quot;&quot;</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[]</span>
                            <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">ids</span> <span class="Symbol">++</span> <span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">iids</span><span class="Symbol">)</span>
            <span class="Symbol">++</span> <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">makeLookup</span> <span class="VarId">cor</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">ids</span> <span class="Symbol">++</span> <span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">iids</span><span class="Symbol">)</span>
            <span class="Keyword">where</span>
              <span class="VarId">makeLookup</span> <span class="VarId">c1</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)=</span> <span class="Symbol">((</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">cor</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">))</span>
    <span class="VarId">doStar</span> <span class="Symbol">::</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">])]</span>
    <span class="VarId">doStar</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">cor</span> <span class="Keyword">of</span>
                      <span class="String">&quot;&quot;</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[]</span>
                      <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[(</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="Symbol">$</span> <span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">ids</span><span class="Symbol">)]</span>
             <span class="Symbol">++</span> <span class="Symbol">[(</span><span class="VarId">cor</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="Symbol">$</span> <span class="VarId">map</span> <span class="VarId">addDetails</span> <span class="VarId">ids</span><span class="Symbol">)]</span>
    <span class="VarId">addDetails</span> <span class="Symbol">(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">src</span><span class="Symbol">,</span><span class="VarId">cor</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span>

<span class="Function">makeStack</span> <span class="VarId">cat</span> <span class="Symbol">(</span><span class="ConId">LBJoinIds</span> <span class="VarId">t1</span> <span class="VarId">t2</span> <span class="VarId">jns</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="Comment">--first get the stacks from t1 and t2</span>
  <span class="Comment">--combine the elements of these filtering out the join ids</span>
  <span class="Symbol">--</span>
  <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">i1</span> <span class="VarId">s1</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">makeStack</span> <span class="VarId">cat</span> <span class="VarId">t1</span>
  <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">i2</span> <span class="VarId">s2</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">makeStack</span> <span class="VarId">cat</span> <span class="VarId">t2</span>
  <span class="Comment">-- get the names and types of the join columns</span>
  <span class="Keyword">let</span> <span class="VarId">jns'</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">jns</span> <span class="Keyword">of</span>
             <span class="ConId">Left</span> <span class="Symbol">()</span> <span class="Symbol">-&gt;</span> <span class="Comment">-- natural join, so we have to work out the names</span>
                        <span class="Comment">-- by looking at the common attributes</span>
                        <span class="Comment">-- we do this by getting the star expansion</span>
                        <span class="Comment">-- with no correlation name, and then finding</span>
                        <span class="Comment">-- the ids which appear in both lists</span>
                        <span class="Comment">-- (so this ignores internal ids)</span>
                 <span class="Keyword">let</span> <span class="VarId">ic1</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">]</span>
                     <span class="VarId">ic1</span> <span class="Symbol">=</span> <span class="VarId">fromRight</span> <span class="Symbol">[]</span> <span class="Symbol">$</span> <span class="VarId">maybe</span> <span class="Symbol">(</span><span class="ConId">Right</span> <span class="Symbol">[])</span> <span class="VarId">id</span> <span class="Symbol">$</span> <span class="VarId">lookup</span> <span class="String">&quot;&quot;</span> <span class="VarId">s1</span>
                     <span class="VarId">ic2</span> <span class="Symbol">=</span> <span class="VarId">fromRight</span> <span class="Symbol">[]</span> <span class="Symbol">$</span> <span class="VarId">maybe</span> <span class="Symbol">(</span><span class="ConId">Right</span> <span class="Symbol">[])</span> <span class="VarId">id</span> <span class="Symbol">$</span> <span class="VarId">lookup</span> <span class="String">&quot;&quot;</span> <span class="VarId">s2</span>
                     <span class="VarId">third</span> <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">n</span>
                     <span class="VarId">ii1</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span>
                     <span class="VarId">ii1</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">third</span> <span class="VarId">ic1</span>
                     <span class="VarId">ii2</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">third</span> <span class="VarId">ic2</span>
                 <span class="Keyword">in</span> <span class="VarId">intersect</span> <span class="VarId">ii1</span> <span class="VarId">ii2</span>
             <span class="ConId">Right</span> <span class="VarId">x</span> <span class="Symbol">-&gt;</span> <span class="VarId">x</span>
      <span class="Comment">-- first prepare for the id lookups</span>
      <span class="Comment">-- remove the join ids from the id lookups</span>
      <span class="VarId">isJid</span> <span class="Symbol">((</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">n</span> <span class="Symbol">`</span><span class="VarId">elem</span><span class="Symbol">`</span> <span class="VarId">jns'</span><span class="Symbol">)</span>
      <span class="VarId">removeJids</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(</span><span class="VarId">not</span> <span class="Symbol">.</span> <span class="VarId">isJid</span><span class="Symbol">)</span>
      <span class="VarId">i1'</span> <span class="Symbol">=</span> <span class="VarId">removeJids</span> <span class="VarId">i1</span>
      <span class="VarId">i2'</span> <span class="Symbol">=</span> <span class="VarId">removeJids</span> <span class="VarId">i2</span>
  <span class="VarId">jids</span> <span class="Symbol">&lt;-</span> <span class="ConId">M.</span><span class="VarId">sequence</span> <span class="Symbol">$</span> <span class="VarId">joinIDTypes</span> <span class="VarId">i1</span> <span class="VarId">i2</span> <span class="VarId">jns'</span>
  <span class="Comment">{-trace (&quot;joinids: &quot; ++ show jids</span>
<span class="Comment">         ++ &quot;\ni1 &quot; ++ show i1</span>
<span class="Comment">         ++ &quot;\ni2 &quot; ++ show i2</span>
<span class="Comment">         ++ &quot;\ni1' &quot; ++ show i1'</span>
<span class="Comment">         ++ &quot;\ni2' &quot; ++ show i2'</span>
<span class="Comment">        ) $ return ()-}</span>
  <span class="Keyword">let</span> <span class="VarId">jidsLk</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span>
      <span class="VarId">jidsLk</span> <span class="Symbol">=</span> <span class="Keyword">if</span> <span class="VarId">null</span> <span class="VarId">i1</span> <span class="Symbol">||</span> <span class="VarId">null</span> <span class="VarId">i2</span>
               <span class="Keyword">then</span> <span class="Symbol">[]</span> <span class="Comment">--error?</span>
               <span class="Keyword">else</span> <span class="Keyword">let</span> <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">sc1</span><span class="Symbol">,</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="VarId">head</span> <span class="VarId">i1</span>
                        <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">sc2</span><span class="Symbol">,</span><span class="VarId">c2</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="VarId">head</span> <span class="VarId">i2</span>
                    <span class="Keyword">in</span> <span class="VarId">flip</span> <span class="VarId">concatMap</span> <span class="VarId">jids</span> <span class="Symbol">$</span> <span class="Symbol">\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[((</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">sc1</span><span class="Symbol">,</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">))</span>
                                                       <span class="Symbol">,((</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">sc1</span><span class="Symbol">,</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">))</span>
                                                       <span class="Symbol">,((</span><span class="VarId">c2</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span> <span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">sc2</span><span class="Symbol">,</span><span class="VarId">c2</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">))</span>
                                                       <span class="Symbol">]</span>
      <span class="Comment">--jidsF :: [FullId]</span>
      <span class="Comment">--jidsF = rights $ map snd jidsLk</span>
      <span class="VarId">newIdLookups</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">jidsLk</span> <span class="Symbol">++</span> <span class="Symbol">(</span><span class="VarId">combineAddAmbiguousErrors</span> <span class="VarId">i1'</span> <span class="VarId">i2'</span><span class="Symbol">))</span>
      <span class="Comment">-- now do the star expansions</span>
      <span class="Comment">-- for each correlation name, remove any ids which match a join id</span>
      <span class="Comment">-- then prepend the join ids to that list</span>
      <span class="VarId">se</span> <span class="Symbol">=</span> <span class="VarId">combineStarExpansions</span> <span class="VarId">s1</span> <span class="VarId">s2</span> <span class="Comment">-- don't know if this is quite right</span>
      <span class="VarId">removeJids1</span> <span class="Symbol">::</span> <span class="ConId">StarLookup</span> <span class="Symbol">-&gt;</span> <span class="ConId">StarLookup</span>
      <span class="VarId">removeJids1</span> <span class="Symbol">(</span><span class="VarId">k</span><span class="Symbol">,</span><span class="VarId">ids</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">k</span><span class="Symbol">,</span> <span class="VarId">fmap</span> <span class="Symbol">(</span><span class="VarId">filter</span> <span class="Symbol">(\(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">n</span> <span class="Symbol">`</span><span class="VarId">notElem</span><span class="Symbol">`</span> <span class="VarId">jns'</span><span class="Symbol">))</span> <span class="VarId">ids</span><span class="Symbol">)</span>
      <span class="VarId">prependJids</span> <span class="Symbol">::</span> <span class="ConId">StarLookup</span> <span class="Symbol">-&gt;</span> <span class="ConId">StarLookup</span>
      <span class="VarId">prependJids</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span> <span class="VarId">lkps</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">lkps</span> <span class="Keyword">of</span>
                                <span class="ConId">Left</span> <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">lkps</span><span class="Symbol">)</span>
                                <span class="ConId">Right</span> <span class="VarId">r</span> <span class="Symbol">|</span> <span class="VarId">null</span> <span class="VarId">r</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">lkps</span><span class="Symbol">)</span>
                                <span class="ConId">Right</span> <span class="VarId">r</span> <span class="Symbol">-&gt;</span> <span class="Keyword">let</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">head</span> <span class="VarId">r</span>
                                               <span class="VarId">ids</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">c1</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">))</span> <span class="VarId">jids</span>
                                           <span class="Keyword">in</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span> <span class="VarId">fmap</span> <span class="Symbol">(</span><span class="VarId">ids</span><span class="Symbol">++)</span> <span class="VarId">lkps</span><span class="Symbol">)</span>
      <span class="VarId">newStarExpansion</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">prependJids</span> <span class="Symbol">.</span> <span class="VarId">removeJids1</span><span class="Symbol">)</span> <span class="VarId">se</span>
      <span class="Comment">-- if we have an alias then we just want unqualified ids, then</span>
      <span class="Comment">-- the same ids with a t3 alias for both ids and star expansion</span>
      <span class="Comment">-- with all the correlation names replaced with the alias</span>
  <span class="Keyword">if</span> <span class="VarId">a</span> <span class="Symbol">==</span> <span class="String">&quot;&quot;</span>
    <span class="Keyword">then</span> <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">LocalBindingsLookup</span> <span class="VarId">newIdLookups</span> <span class="VarId">newStarExpansion</span>
    <span class="Keyword">else</span> <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">LocalBindingsLookup</span> <span class="Symbol">(</span><span class="VarId">aliasIds</span> <span class="VarId">newIdLookups</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">aliasExps</span> <span class="VarId">newStarExpansion</span><span class="Symbol">)</span>
  <span class="Keyword">where</span>
    <span class="VarId">aliasIds</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span>
    <span class="VarId">aliasIds</span> <span class="VarId">lkps</span> <span class="Symbol">=</span> <span class="Keyword">let</span> <span class="VarId">trimmed</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(\((</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">),</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">c</span> <span class="Symbol">==</span> <span class="String">&quot;&quot;</span><span class="Symbol">)</span> <span class="VarId">lkps</span>
                        <span class="VarId">aliased</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">i</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span> <span class="VarId">fmap</span> <span class="VarId">replaceCName</span> <span class="VarId">i</span><span class="Symbol">))</span> <span class="VarId">trimmed</span>
                    <span class="Keyword">in</span> <span class="VarId">aliased</span> <span class="Symbol">++</span> <span class="VarId">map</span> <span class="Symbol">(\((</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span><span class="VarId">i</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">((</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span><span class="VarId">i</span><span class="Symbol">))</span> <span class="VarId">aliased</span>
    <span class="VarId">aliasExps</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">StarLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">StarLookup</span><span class="Symbol">]</span>
    <span class="VarId">aliasExps</span> <span class="VarId">lkps</span> <span class="Symbol">=</span> <span class="Keyword">let</span> <span class="VarId">is</span> <span class="Symbol">=</span> <span class="VarId">fromMaybe</span> <span class="Symbol">(</span><span class="VarId">error</span> <span class="String">&quot;localbindingsinternal.makestack : fromJust&quot;</span><span class="Symbol">)</span> <span class="Symbol">$</span>
                              <span class="VarId">lookup</span> <span class="String">&quot;&quot;</span> <span class="VarId">lkps</span>
                         <span class="VarId">aliased</span> <span class="Symbol">=</span> <span class="VarId">fmap</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">replaceCName</span><span class="Symbol">)</span> <span class="VarId">is</span>
                     <span class="Keyword">in</span> <span class="Symbol">[(</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="VarId">aliased</span><span class="Symbol">),</span> <span class="Symbol">(</span><span class="VarId">a</span><span class="Symbol">,</span> <span class="VarId">aliased</span><span class="Symbol">)]</span>
    <span class="VarId">replaceCName</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span>
    <span class="VarId">joinIDTypes</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">String</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">E</span> <span class="Symbol">(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
    <span class="VarId">joinIDTypes</span> <span class="VarId">i1</span> <span class="VarId">i2</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">joinIDType</span> <span class="VarId">i1</span> <span class="VarId">i2</span><span class="Symbol">)</span>
    <span class="VarId">joinIDType</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)</span>
    <span class="VarId">joinIDType</span> <span class="VarId">i1</span> <span class="VarId">i2</span> <span class="VarId">s</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
      <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">ty1</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">fromMaybe</span> <span class="Symbol">(</span><span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">MissingJoinAttribute</span><span class="Symbol">])</span> <span class="Symbol">$</span>
                     <span class="VarId">lookup</span> <span class="Symbol">(</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="VarId">s</span><span class="Symbol">)</span> <span class="VarId">i1</span>
      <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">ty2</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">fromMaybe</span> <span class="Symbol">(</span><span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">MissingJoinAttribute</span><span class="Symbol">])</span> <span class="Symbol">$</span>
                     <span class="VarId">lookup</span> <span class="Symbol">(</span><span class="String">&quot;&quot;</span><span class="Symbol">,</span><span class="VarId">s</span><span class="Symbol">)</span> <span class="VarId">i2</span>
      <span class="VarId">ty</span> <span class="Symbol">&lt;-</span> <span class="VarId">resolveResultSetType</span> <span class="VarId">cat</span> <span class="Symbol">[</span><span class="VarId">ty1</span><span class="Symbol">,</span><span class="VarId">ty2</span><span class="Symbol">]</span>
      <span class="VarId">return</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">ty</span><span class="Symbol">)</span>

<span class="Function">makeStack</span> <span class="VarId">cat</span> <span class="Symbol">(</span><span class="ConId">LBParallel</span> <span class="VarId">u1</span> <span class="VarId">u2</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="Comment">-- get the two stacks,</span>
  <span class="Comment">-- for any keys that appear in both respective lookups, replace with ambigious error</span>
  <span class="Comment">-- and concatenate the lot</span>
  <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">i1</span> <span class="VarId">s1</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">makeStack</span> <span class="VarId">cat</span> <span class="VarId">u1</span>
  <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">i2</span> <span class="VarId">s2</span><span class="Symbol">)</span> <span class="Symbol">&lt;-</span> <span class="VarId">makeStack</span> <span class="VarId">cat</span> <span class="VarId">u2</span>
  <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">LocalBindingsLookup</span> <span class="Symbol">(</span><span class="VarId">combineAddAmbiguousErrors</span> <span class="VarId">i1</span> <span class="VarId">i2</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">combineStarExpansions</span> <span class="VarId">s1</span> <span class="VarId">s2</span>

<span class="Function">combineStarExpansions</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">StarLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">StarLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">StarLookup</span><span class="Symbol">]</span>
<span class="Function">combineStarExpansions</span> <span class="VarId">s1</span> <span class="VarId">s2</span> <span class="Symbol">=</span>
  <span class="Keyword">let</span> <span class="VarId">p</span> <span class="Symbol">::</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">FullId</span><span class="Symbol">])])]</span>
      <span class="VarId">p</span> <span class="Symbol">=</span> <span class="VarId">npartition</span> <span class="VarId">fst</span> <span class="Symbol">(</span><span class="VarId">s1</span> <span class="Symbol">++</span> <span class="VarId">s2</span><span class="Symbol">)</span>
  <span class="Keyword">in</span> <span class="VarId">flip</span> <span class="VarId">map</span> <span class="VarId">p</span> <span class="Symbol">$</span> <span class="Symbol">\(</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">b</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">(</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">concat</span> <span class="Symbol">&lt;$&gt;</span> <span class="ConId">M.</span><span class="VarId">sequence</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">snd</span> <span class="VarId">b</span><span class="Symbol">))</span>

<span class="Function">combineAddAmbiguousErrors</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span>
<span class="Function">combineAddAmbiguousErrors</span> <span class="VarId">i1</span> <span class="VarId">i2</span> <span class="Symbol">=</span>
  <span class="Keyword">let</span> <span class="VarId">commonIds</span> <span class="Symbol">=</span> <span class="VarId">intersect</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">fst</span> <span class="VarId">i1</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="VarId">map</span> <span class="VarId">fst</span> <span class="VarId">i2</span><span class="Symbol">)</span>
      <span class="VarId">removeCommonIds</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(\</span><span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">fst</span> <span class="VarId">a</span> <span class="Symbol">`</span><span class="VarId">notElem</span><span class="Symbol">`</span> <span class="VarId">commonIds</span><span class="Symbol">)</span>
      <span class="VarId">fi1</span> <span class="Symbol">=</span> <span class="VarId">removeCommonIds</span> <span class="VarId">i1</span>
      <span class="VarId">fi2</span> <span class="Symbol">=</span> <span class="VarId">removeCommonIds</span> <span class="VarId">i2</span>
      <span class="VarId">errors</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="Symbol">(\(</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">((</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">),</span><span class="ConId">Left</span> <span class="Symbol">[</span><span class="ConId">AmbiguousIdentifier</span> <span class="Symbol">$</span> <span class="VarId">showID</span> <span class="VarId">c</span> <span class="VarId">n</span><span class="Symbol">]))</span> <span class="VarId">commonIds</span>
  <span class="Keyword">in</span> <span class="VarId">fi1</span> <span class="Symbol">++</span> <span class="VarId">fi2</span> <span class="Symbol">++</span> <span class="VarId">errors</span></pre></div></div></div><p
    >===============================================================================</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">mtl</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">mtl</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">toLower</span>

<span class="Function">showID</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
<span class="Function">showID</span> <span class="VarId">cor</span> <span class="VarId">i</span> <span class="Symbol">=</span> <span class="Keyword">if</span> <span class="VarId">cor</span> <span class="Symbol">==</span> <span class="String">&quot;&quot;</span> <span class="Keyword">then</span> <span class="VarId">i</span> <span class="Keyword">else</span> <span class="VarId">cor</span> <span class="Symbol">++</span> <span class="String">&quot;.&quot;</span> <span class="Symbol">++</span> <span class="VarId">i</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >expand composites</p
    ><p
    >slightly dodgy - run through all the unqualified ids in the idlookups, and if any have a composite type, add each element of that composite under the correlation name of the idlookup itself, and add a star expansion for that name also. This pretends that using a correlation name, composite name and id name as a three part id isn't possible</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">expandComposites</span> <span class="Symbol">::</span> <span class="ConId">Catalog</span> <span class="Symbol">-&gt;</span> <span class="ConId">LocalBindingsLookup</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="ConId">LocalBindingsLookup</span>
<span class="Function">expandComposites</span> <span class="VarId">cat</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="VarId">idlkp</span> <span class="VarId">stlkp</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="Keyword">let</span> <span class="VarId">unqids</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(\((</span><span class="VarId">a</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">),</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span> <span class="Symbol">==</span> <span class="String">&quot;&quot;</span><span class="Symbol">)</span> <span class="VarId">idlkp</span>
      <span class="VarId">strip</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">snd</span> <span class="VarId">unqids</span>
      <span class="VarId">getComposites</span> <span class="Symbol">=</span> <span class="VarId">filter</span> <span class="Symbol">(\(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">isCt</span> <span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">rights</span> <span class="VarId">strip</span>
  <span class="VarId">comps</span> <span class="Symbol">&lt;-</span> <span class="VarId">mapM</span> <span class="VarId">compExp</span> <span class="VarId">getComposites</span>
  <span class="Keyword">let</span> <span class="VarId">sts</span> <span class="Symbol">=</span> <span class="VarId">map</span> <span class="VarId">toStarLookup</span> <span class="VarId">comps</span>
  <span class="ConId">Right</span> <span class="Symbol">(</span><span class="ConId">LocalBindingsLookup</span> <span class="Symbol">(</span><span class="VarId">idlkp</span> <span class="Symbol">++</span> <span class="Symbol">(</span><span class="VarId">concat</span> <span class="VarId">comps</span><span class="Symbol">))</span> <span class="Symbol">(</span><span class="VarId">stlkp</span> <span class="Symbol">++</span> <span class="VarId">sts</span><span class="Symbol">))</span>
  <span class="Keyword">where</span>
    <span class="VarId">isCt</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">isCompositeType</span> <span class="VarId">t</span>
    <span class="VarId">isCt</span> <span class="VarId">t</span> <span class="Symbol">=</span> <span class="VarId">isCompositeType</span> <span class="VarId">t</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">::</span> <span class="ConId">Type</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)]</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">SetOfType</span> <span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">getCompFields</span> <span class="VarId">t</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">PgRecord</span> <span class="ConId">Nothing</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="Symbol">[]</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">PgRecord</span> <span class="Symbol">(</span><span class="ConId">Just</span> <span class="VarId">t</span><span class="Symbol">))</span> <span class="Symbol">=</span> <span class="VarId">getCompFields</span> <span class="VarId">t</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">CompositeType</span> <span class="VarId">f</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">return</span> <span class="VarId">f</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">NamedCompositeType</span> <span class="VarId">s</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="VarId">catCompositePublicAttrs</span> <span class="VarId">cat</span> <span class="Symbol">[]</span> <span class="VarId">s</span>
    <span class="VarId">getCompFields</span> <span class="Symbol">(</span><span class="ConId">AnonymousRecordType</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="Symbol">[]</span> <span class="Comment">-- ??</span>
    <span class="VarId">getCompFields</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">Right</span> <span class="Symbol">[]</span>
    <span class="VarId">compExp</span> <span class="Symbol">::</span> <span class="ConId">FullId</span> <span class="Symbol">-&gt;</span> <span class="ConId">E</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span>
    <span class="VarId">compExp</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
      <span class="VarId">f</span> <span class="Symbol">&lt;-</span> <span class="VarId">getCompFields</span> <span class="VarId">t</span>
      <span class="VarId">return</span> <span class="Symbol">$</span> <span class="VarId">flip</span> <span class="VarId">map</span> <span class="VarId">f</span> <span class="Symbol">$</span> <span class="Symbol">\(</span><span class="VarId">n1</span><span class="Symbol">,</span><span class="VarId">t1</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="Symbol">((</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">n1</span><span class="Symbol">),</span><span class="ConId">Right</span> <span class="Symbol">(</span><span class="VarId">s</span><span class="Symbol">,</span><span class="VarId">n</span><span class="Symbol">,</span><span class="VarId">n1</span><span class="Symbol">,</span><span class="VarId">t1</span><span class="Symbol">))</span>
    <span class="VarId">toStarLookup</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">IDLookup</span><span class="Symbol">]</span> <span class="Symbol">-&gt;</span> <span class="ConId">StarLookup</span>
    <span class="VarId">toStarLookup</span> <span class="VarId">ids</span> <span class="Symbol">=</span>
      <span class="Keyword">let</span> <span class="VarId">fids</span><span class="Symbol">::[</span><span class="ConId">FullId</span><span class="Symbol">]</span>
          <span class="VarId">fids</span> <span class="Symbol">=</span> <span class="VarId">rights</span> <span class="Symbol">$</span> <span class="VarId">map</span> <span class="VarId">snd</span> <span class="VarId">ids</span>
          <span class="Symbol">(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">c</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">if</span> <span class="VarId">null</span> <span class="VarId">fids</span> <span class="Keyword">then</span> <span class="Symbol">(</span><span class="VarId">undefined</span><span class="Symbol">,</span><span class="String">&quot;ERROR&quot;</span><span class="Symbol">,</span><span class="VarId">undefined</span><span class="Symbol">,</span><span class="VarId">undefined</span><span class="Symbol">)</span> <span class="Keyword">else</span> <span class="VarId">head</span> <span class="VarId">fids</span>
      <span class="Keyword">in</span> <span class="Symbol">(</span><span class="VarId">c</span><span class="Symbol">,</span><span class="ConId">Right</span> <span class="VarId">fids</span><span class="Symbol">)-}</span></pre></div></div></div><br
     /><br
     /><br
     /><div class="footer"
    >generated on 01/29/11 20:06:46, hssqlppp-0.3.0</div
    ></body
  ></html
>
