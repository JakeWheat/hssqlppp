<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >AstAnnotation</title
    ><link href="../../../../../../main.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><div class="header"
    ><a href="../../../../../../index.html"
      >HsSqlPpp-0.3.0</a
      ></div
    ><br
     /><br
     /><br
     /><p
    >The annotation data types and utilities for working with them.</p
    ><p
    >Annotations are used to store source positions, types, errors, warnings, catalog deltas, information, and other stuff a client might want to use when looking at an ast. Internal annotations which are used in the type-checking/ annotation process use the attribute grammar code and aren't exposed.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-# LANGUAGE ExistentialQuantification, DeriveDataTypeable,ScopedTypeVariables,</span>
<span class="Comment">  RankNTypes,FlexibleContexts #-}</span>

<span class="Keyword">module</span> <span class="ConId">Database.HsSqlPpp.AstInternals.AstAnnotation</span>
    <span class="Symbol">(</span>
     <span class="ConId">Annotation</span><span class="Symbol">(..)</span>
    <span class="Symbol">,</span><span class="ConId">SourcePosition</span>
    <span class="Symbol">,</span><span class="ConId">StatementType</span>
    <span class="Symbol">,</span><span class="VarId">getAnnotation</span>
    <span class="Symbol">,</span><span class="VarId">updateAnnotations</span>
    <span class="Symbol">,</span><span class="VarId">getAnnotations</span>
    <span class="Symbol">,</span><span class="VarId">emptyAnnotation</span>
    <span class="Symbol">,</span><span class="VarId">getTypeAnnotation</span>
    <span class="Symbol">,</span><span class="VarId">updateAnnotation</span>
    <span class="Symbol">)</span> <span class="Keyword">where</span>

<span class="Keyword">import</span> <span class="ConId">Data.Generics</span>
<span class="Comment">---import Control.Arrow</span>
<span class="Keyword">import</span> <span class="ConId">Data.Generics.Uniplate.Data</span>
<span class="Comment">--import Debug.Trace</span>

<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.AstInternals.TypeType</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.AstInternals.Catalog.CatalogInternal</span>
<span class="Comment">--import Database.HsSqlPpp.Utils.Utils</span>

<span class="Keyword">type</span> <span class="ConId">SourcePosition</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Int</span><span class="Symbol">,</span><span class="ConId">Int</span><span class="Symbol">)</span>
<span class="Keyword">type</span> <span class="ConId">StatementType</span> <span class="Symbol">=</span> <span class="Symbol">([</span><span class="ConId">Type</span><span class="Symbol">],[(</span><span class="ConId">String</span><span class="Symbol">,</span><span class="ConId">Type</span><span class="Symbol">)])</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">-- | Annotation type - one of these is attached to most of the</span>
<span class="Comment">-- data types used in the ast.</span>
<span class="Keyword">data</span> <span class="ConId">Annotation</span> <span class="Symbol">=</span> <span class="ConId">Annotation</span> <span class="Symbol">{</span><span class="VarId">asrc</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">SourcePosition</span>
                             <span class="Symbol">,</span><span class="VarId">atype</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">Type</span> <span class="Comment">-- type of the node, nothing if type error prevents determining type</span>
                             <span class="Symbol">,</span><span class="VarId">errs</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">TypeError</span><span class="Symbol">]</span> <span class="Comment">-- any type errors</span>
                             <span class="Symbol">,</span><span class="VarId">stType</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">StatementType</span> <span class="Comment">-- 'statement type' - used for getting the in and out types of a parameterized statement</span>
                             <span class="Symbol">,</span><span class="VarId">catUpd</span> <span class="Symbol">::</span> <span class="Symbol">[</span><span class="ConId">CatalogUpdate</span><span class="Symbol">]</span> <span class="Comment">-- any catalog updates that a ddl statement produces</span>
                             <span class="Symbol">,</span><span class="VarId">fnProt</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">FunctionPrototype</span> <span class="Comment">-- the matched function prototype for a funcall</span>
                             <span class="Symbol">,</span><span class="VarId">infType</span> <span class="Symbol">::</span> <span class="ConId">Maybe</span> <span class="ConId">Type</span><span class="Symbol">}</span> <span class="Comment">-- 'inferred' type - fake type inference used for getting the type of ? placeholders in parameterized statements</span>
                  <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span> <span class="ConId">Show</span><span class="Symbol">,</span><span class="ConId">Typeable</span><span class="Symbol">,</span><span class="ConId">Data</span><span class="Symbol">)</span>

<span class="Function">emptyAnnotation</span> <span class="Symbol">::</span> <span class="ConId">Annotation</span>
<span class="Function">emptyAnnotation</span> <span class="Symbol">=</span> <span class="ConId">Annotation</span> <span class="ConId">Nothing</span> <span class="ConId">Nothing</span> <span class="Symbol">[]</span> <span class="ConId">Nothing</span> <span class="Symbol">[]</span> <span class="ConId">Nothing</span> <span class="ConId">Nothing</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">-- | get the annotation for the root element of the tree passed</span>
<span class="Function">getAnnotation</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="ConId">Annotation</span>
<span class="Function">getAnnotation</span> <span class="Symbol">=</span> <span class="VarId">head</span> <span class="Symbol">.</span> <span class="VarId">childrenBi</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">getAnnotations</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="ConId">Annotation</span><span class="Symbol">]</span>
<span class="Function">getAnnotations</span> <span class="VarId">st</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="VarId">x</span> <span class="Symbol">|</span> <span class="VarId">x</span> <span class="Symbol">&lt;-</span> <span class="VarId">universeBi</span> <span class="VarId">st</span><span class="Symbol">]</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">updateAnnotations</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="Symbol">(</span><span class="ConId">Annotation</span> <span class="Symbol">-&gt;</span> <span class="ConId">Annotation</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span>
<span class="Function">updateAnnotations</span> <span class="Symbol">=</span> <span class="VarId">transformBi</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">getTypeAnnotation</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="ConId">Maybe</span> <span class="ConId">Type</span>
<span class="Function">getTypeAnnotation</span> <span class="Symbol">=</span> <span class="VarId">atype</span> <span class="Symbol">.</span> <span class="VarId">getAnnotation</span></pre></div></div></div><p
    >Use syb/uniplate to pull annotation values from an ast.</p
    ><p
    >I like to cut and paste code from the internet which I don't understand, then keep changing it till it compiles and passes the tests.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{- -- | run through the ast, and pull the type annotation from each</span>
<span class="Comment">-- of the top level items.</span>
<span class="Comment">getTypeAnnotation :: (Show a, Data a) =&gt; a -&gt; Type</span>
<span class="Comment">getTypeAnnotation st =</span>
<span class="Comment">    typeAnnot $ getTopLevelAnnotation st</span>
<span class="Comment">    where</span>
<span class="Comment">      typeAnnot :: Annotation -&gt; Type</span>
<span class="Comment">      typeAnnot (x:xs) = case x of</span>
<span class="Comment">                                TypeAnnotation t -&gt; t</span>
<span class="Comment">                                _ -&gt; typeAnnot xs</span>
<span class="Comment">      typeAnnot [] = TypeCheckFailed -- error &quot;couldn't find type annotation&quot;</span>

<span class="Comment">-- | Run through the ast given and return a list of statementtypes</span>
<span class="Comment">-- from the top level items.</span>
<span class="Comment">getTopLevelInfos :: Data a =&gt; [a] -&gt; [Maybe StatementType]</span>
<span class="Comment">getTopLevelInfos = map (getSIAnnotation . getTopLevelAnnotation)</span>

<span class="Comment">getTopLevelCatUpdates ::  Data a =&gt; [a] -&gt; [[CatalogUpdate]]</span>
<span class="Comment">getTopLevelCatUpdates = map (getEuAnnotation . getTopLevelAnnotation)</span>
</pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">-- | runs through the ast given and returns a list of all the type errors</span>
<span class="Comment">-- in the ast. Recurses into all ast nodes to find type errors.</span>
<span class="Comment">-- This is the function to use to see if an ast has passed the type checking process.</span>
<span class="Comment">-- Returns a Maybe SourcePos and the list of type errors for each node which has one or</span>
<span class="Comment">-- more type errors.</span>
<span class="Function">getTypeErrors</span> <span class="Symbol">::</span> <span class="Symbol">(</span><span class="ConId">Data</span> <span class="VarId">a</span><span class="Symbol">)</span> <span class="Symbol">=&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[(</span><span class="ConId">Maybe</span> <span class="ConId">AnnotationElement</span><span class="Symbol">,[</span><span class="ConId">TypeError</span><span class="Symbol">])]</span>
<span class="Function">getTypeErrors</span> <span class="VarId">sts</span> <span class="Symbol">=</span>
    <span class="VarId">filter</span> <span class="Symbol">(\(</span><span class="VarId">_</span><span class="Symbol">,</span><span class="VarId">te</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">not</span> <span class="Symbol">$</span> <span class="VarId">null</span> <span class="VarId">te</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">map</span> <span class="Symbol">(</span><span class="VarId">gtsp</span> <span class="Symbol">&amp;&amp;&amp;</span> <span class="VarId">gte</span><span class="Symbol">)</span> <span class="Symbol">$</span> <span class="VarId">getAnnotations</span> <span class="VarId">sts</span>
    <span class="Keyword">where</span>
      <span class="VarId">gte</span> <span class="Symbol">(</span><span class="VarId">a</span><span class="Symbol">:</span><span class="Keyword">as</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">a</span> <span class="Keyword">of</span>
                    <span class="ConId">TypeErrorA</span> <span class="VarId">e</span> <span class="Symbol">-&gt;</span> <span class="VarId">e</span><span class="Symbol">:</span><span class="VarId">gte</span> <span class="Keyword">as</span>
                    <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="VarId">gte</span> <span class="Keyword">as</span>
      <span class="VarId">gte</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="Symbol">[]</span>
      <span class="VarId">gtsp</span> <span class="Symbol">(</span><span class="VarId">a</span><span class="Symbol">:</span><span class="Keyword">as</span><span class="Symbol">)</span> <span class="Symbol">=</span> <span class="Keyword">case</span> <span class="VarId">a</span> <span class="Keyword">of</span>
                    <span class="VarId">s</span><span class="Symbol">@(</span><span class="ConId">SourcePos</span> <span class="VarId">_</span> <span class="VarId">_</span> <span class="VarId">_</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="ConId">Just</span> <span class="VarId">s</span>
                    <span class="VarId">_</span> <span class="Symbol">-&gt;</span> <span class="VarId">gtsp</span> <span class="Keyword">as</span>
      <span class="VarId">gtsp</span> <span class="VarId">_</span> <span class="Symbol">=</span> <span class="ConId">Nothing</span></pre></div></div></div><pre
    ><code
      >question:
if a node has no source position e.g. the all in select all or select
   distinct may correspond to a token or may be synthesized as the
   default if neither all or distinct is present. Should this have the
   source position of where the token would have appeared, should it
   inherit it from its parent, should there be a separate ctor to
   represent a fake node with no source position?
</code
      ></pre
    ><p
    >hack job, often not interested in the source positions when testing the asts produced, so this function will reset all the source positions to empty (&quot;&quot;, 0, 0) so we can compare them for equality, etc. without having to get the positions correct.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Symbol">-}</span></pre></div></div></div><blockquote
    ><p
      >-- | strip all the annotations from a tree. E.g. can be used to compare -- two asts are the same, ignoring any source position annotation differences. stripAnnotations :: Data a =&gt; a -&gt; a stripAnnotations = filterAnnotations (const False)</p
      ></blockquote
    ><blockquote
    ><p
      >filterAnnotations :: Data a =&gt; (Annotation -&gt; Bool) -&gt; a -&gt; a filterAnnotations f = transformBi (filter f)</p
      ></blockquote
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">
<span class="Comment">-- | Update all the annotations in a tree using the function supplied</span>
<span class="Function">updateAnnotation</span> <span class="Symbol">::</span> <span class="ConId">Data</span> <span class="VarId">a</span> <span class="Symbol">=&gt;</span> <span class="Symbol">(</span><span class="ConId">Annotation</span> <span class="Symbol">-&gt;</span> <span class="ConId">Annotation</span><span class="Symbol">)</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span> <span class="Symbol">-&gt;</span> <span class="VarId">a</span>
<span class="Function">updateAnnotation</span> <span class="VarId">f</span> <span class="Symbol">=</span> <span class="VarId">gmapT</span> <span class="Symbol">(</span><span class="VarId">mkT</span> <span class="VarId">f</span><span class="Symbol">)</span>
</pre></div></div></div><blockquote
    ><p
      >case gmapQ (mkQ [] f) a of an:_ -&gt; an [] -&gt; [] where f :: Annotation -&gt; Annotation f = id</p
      ></blockquote
    ><blockquote
    ><p
      >getAnnotations :: Data a =&gt; a -&gt; [Annotation] getAnnotations = listifyWholeLists ((_::Annotation) -&gt; True)</p
      ></blockquote
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Comment">{-getSIAnnotation :: Annotation -&gt; Maybe StatementType</span>
<span class="Comment">getSIAnnotation (x:xs) = case x of</span>
<span class="Comment">                                StatementTypeA t -&gt; Just t</span>
<span class="Comment">                                _ -&gt; getSIAnnotation xs</span>
<span class="Comment">getSIAnnotation []  = Nothing</span>

<span class="Comment">getEuAnnotation :: Annotation -&gt; [CatalogUpdate]</span>
<span class="Comment">getEuAnnotation (x:xs) = case x of</span>
<span class="Comment">                                CatUpdates t -&gt; t</span>
<span class="Comment">                                _ -&gt; getEuAnnotation xs</span>
<span class="Comment">getEuAnnotation [] = []-}</span></pre></div></div></div><hr
     /><p
    >utils</p
    ><blockquote
    ><p
      >listifyWholeLists :: Typeable b =&gt; ([b] -&gt; Bool) -&gt; GenericQ [[b]] listifyWholeLists blp = flip (synthesize id (.) (mkQ id ( _ -&gt; if blp bl then (bl:) else id))) []</p
      ></blockquote
    ><p
    >this might need to be maybe and change head?</p
    ><blockquote
    ><p
      >getTopLevelAnnotation :: Data a =&gt; a -&gt; Annotation getTopLevelAnnotation st = head $ childrenBi st</p
      ></blockquote
    ><br
     /><br
     /><br
     /><div class="footer"
    >generated on 01/31/11 20:00:52, hssqlppp-0.3.0</div
    ></body
  ></html
>
