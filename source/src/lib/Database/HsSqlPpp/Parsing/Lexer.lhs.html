<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Lexer</title
    ><link href="../../../../../../main.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><div class="header"
    ><a href="../../../../../../index.html"
      >HsSqlPpp-0.3.0</a
      ></div
    ><br
     /><br
     /><br
     /><p
    >This file contains the lexer for sql source text.</p
    ><p
    >Lexicon:</p
    ><pre
    ><code
      >string
identifier or keyword
symbols - operators and ;,()[]
positional arg
int
float
copy payload (used to lex copy from stdin data)
</code
      ></pre
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">module</span> <span class="ConId">Database.HsSqlPpp.Parsing.Lexer</span> <span class="Symbol">(</span>
              <span class="ConId">Token</span>
             <span class="Symbol">,</span><span class="ConId">Tok</span><span class="Symbol">(..)</span>
             <span class="Symbol">,</span><span class="VarId">lexSqlFile</span>
             <span class="Symbol">,</span><span class="VarId">lexSqlText</span>
             <span class="Symbol">,</span><span class="VarId">lexSqlTextWithPosition</span>
             <span class="Symbol">,</span><span class="VarId">identifierString</span>
             <span class="Symbol">,</span><span class="ConId">LexState</span>
             <span class="Symbol">)</span> <span class="Keyword">where</span>
<span class="Keyword">import</span> <span class="ConId">Text.Parsec</span> <span class="Keyword">hiding</span><span class="Symbol">(</span><span class="VarId">many</span><span class="Symbol">,</span> <span class="VarId">optional</span><span class="Symbol">,</span> <span class="Symbol">(&lt;|&gt;))</span>
<span class="Keyword">import</span> <span class="Keyword">qualified</span> <span class="ConId">Text.Parsec.Token</span> <span class="Keyword">as</span> <span class="ConId">P</span>
<span class="Keyword">import</span> <span class="ConId">Text.Parsec.Language</span>
<span class="Comment">--import Text.Parsec.String</span>
<span class="Keyword">import</span> <span class="ConId">Text.Parsec.Pos</span>

<span class="Keyword">import</span> <span class="ConId">Control.Applicative</span>
<span class="Keyword">import</span> <span class="ConId">Control.Monad.Identity</span>

<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Parsing.ParseErrors</span>
<span class="Keyword">import</span> <span class="ConId">Database.HsSqlPpp.Utils.Utils</span>
<span class="Comment">-- import Database.HsSqlPpp.Ast.Name</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >= data types</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Keyword">type</span> <span class="ConId">Token</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="ConId">SourcePos</span><span class="Symbol">,</span> <span class="ConId">Tok</span><span class="Symbol">)</span>

<span class="Keyword">data</span> <span class="ConId">Tok</span> <span class="Symbol">=</span> <span class="ConId">StringTok</span> <span class="ConId">String</span> <span class="ConId">String</span> <span class="Comment">--delim, value (delim will one of</span>
                                   <span class="Comment">--', $$, $[stuff]$</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">         <span class="Symbol">|</span> <span class="ConId">IdStringTok</span> <span class="ConId">String</span> <span class="Comment">-- either a identifier component (without .) or a *</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">         <span class="Symbol">|</span> <span class="ConId">SymbolTok</span> <span class="ConId">String</span> <span class="Comment">-- operators, and ()[],;: and also .</span>
                            <span class="Comment">-- '*' is currently always lexed as an id</span>
                            <span class="Comment">--   rather than an operator</span>
                            <span class="Comment">-- this gets fixed in the parsing stage</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">         <span class="Symbol">|</span> <span class="ConId">PositionalArgTok</span> <span class="ConId">Integer</span> <span class="Comment">-- used for $1, etc.</span></pre></div></div></div><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">         <span class="Symbol">|</span> <span class="ConId">FloatTok</span> <span class="ConId">Double</span>
         <span class="Symbol">|</span> <span class="ConId">IntegerTok</span> <span class="ConId">Integer</span>
         <span class="Symbol">|</span> <span class="ConId">CopyPayloadTok</span> <span class="ConId">String</span> <span class="Comment">-- support copy from stdin; with inline data</span>
           <span class="Keyword">deriving</span> <span class="Symbol">(</span><span class="ConId">Eq</span><span class="Symbol">,</span><span class="ConId">Show</span><span class="Symbol">)</span>

<span class="Keyword">type</span> <span class="ConId">LexState</span> <span class="Symbol">=</span> <span class="Symbol">[</span><span class="ConId">Tok</span><span class="Symbol">]</span>

<span class="Function">lexSqlFile</span> <span class="Symbol">::</span> <span class="ConId">FilePath</span> <span class="Symbol">-&gt;</span> <span class="ConId">IO</span> <span class="Symbol">(</span><span class="ConId">Either</span> <span class="ConId">ParseErrorExtra</span> <span class="Symbol">[</span><span class="ConId">Token</span><span class="Symbol">])</span>
<span class="Function">lexSqlFile</span> <span class="VarId">f</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
  <span class="VarId">te</span> <span class="Symbol">&lt;-</span> <span class="VarId">readFile</span> <span class="VarId">f</span>
  <span class="Keyword">let</span> <span class="VarId">x</span> <span class="Symbol">=</span> <span class="VarId">runParser</span> <span class="VarId">sqlTokens</span> <span class="Symbol">[]</span> <span class="VarId">f</span> <span class="VarId">te</span>
  <span class="VarId">return</span> <span class="Symbol">$</span> <span class="VarId">toParseErrorExtra</span> <span class="VarId">x</span> <span class="ConId">Nothing</span> <span class="VarId">te</span>

<span class="Function">lexSqlText</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="ConId">ParseErrorExtra</span> <span class="Symbol">[</span><span class="ConId">Token</span><span class="Symbol">]</span>
<span class="Function">lexSqlText</span> <span class="VarId">f</span> <span class="VarId">s</span> <span class="Symbol">=</span> <span class="VarId">toParseErrorExtra</span> <span class="Symbol">(</span><span class="VarId">runParser</span> <span class="VarId">sqlTokens</span> <span class="Symbol">[]</span> <span class="VarId">f</span> <span class="VarId">s</span><span class="Symbol">)</span> <span class="ConId">Nothing</span> <span class="VarId">s</span>

<span class="Function">lexSqlTextWithPosition</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">Int</span> <span class="Symbol">-&gt;</span> <span class="ConId">Int</span> <span class="Symbol">-&gt;</span> <span class="ConId">String</span>
                       <span class="Symbol">-&gt;</span> <span class="ConId">Either</span> <span class="ConId">ParseErrorExtra</span> <span class="Symbol">[</span><span class="ConId">Token</span><span class="Symbol">]</span>
<span class="Function">lexSqlTextWithPosition</span> <span class="VarId">f</span> <span class="VarId">l</span> <span class="VarId">c</span> <span class="VarId">s</span> <span class="Symbol">=</span>
  <span class="VarId">toParseErrorExtra</span> <span class="Symbol">(</span><span class="VarId">runParser</span> <span class="Symbol">(</span><span class="Keyword">do</span>
                                <span class="VarId">setPosition</span> <span class="Symbol">(</span><span class="VarId">newPos</span> <span class="VarId">f</span> <span class="VarId">l</span> <span class="VarId">c</span><span class="Symbol">)</span>
                                <span class="VarId">sqlTokens</span><span class="Symbol">)</span> <span class="Symbol">[]</span> <span class="VarId">f</span> <span class="VarId">s</span><span class="Symbol">)</span> <span class="Symbol">(</span><span class="ConId">Just</span> <span class="Symbol">(</span><span class="VarId">l</span><span class="Symbol">,</span><span class="VarId">c</span><span class="Symbol">))</span> <span class="VarId">s</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >= lexers</p
    ><p
    >lexer for tokens, contains a hack for copy from stdin with inline table data.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">sqlTokens</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="Symbol">[</span><span class="ConId">Token</span><span class="Symbol">]</span>
<span class="Function">sqlTokens</span> <span class="Symbol">=</span>
  <span class="VarId">setState</span> <span class="Symbol">[]</span> <span class="Symbol">&gt;&gt;</span>
  <span class="VarId">whiteSpace</span> <span class="Symbol">&gt;&gt;</span>
  <span class="VarId">many</span> <span class="VarId">sqlToken</span> <span class="Symbol">&lt;*</span> <span class="VarId">eof</span></pre></div></div></div><p
    >Lexer for an individual token.</p
    ><p
    >What we could do is lex lazily and when the lexer reads a copy from stdin statement, it switches lexers to lex the inline table data, then switches back. Don't know how to do this in parsec, or even if it is possible, so as a work around, we use the state to trap if we've just seen 'from stdin;', if so, we read the copy payload as one big token, otherwise we read a normal token.</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">sqlToken</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Token</span>
<span class="Function">sqlToken</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
           <span class="VarId">sp</span> <span class="Symbol">&lt;-</span> <span class="VarId">getPosition</span>
           <span class="VarId">sta</span> <span class="Symbol">&lt;-</span> <span class="VarId">getState</span>
           <span class="VarId">t</span> <span class="Symbol">&lt;-</span> <span class="Keyword">if</span> <span class="VarId">sta</span> <span class="Symbol">==</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">,</span><span class="VarId">st</span><span class="Symbol">,</span><span class="VarId">mt</span><span class="Symbol">]</span>
                <span class="Keyword">then</span> <span class="VarId">copyPayload</span>
                <span class="Keyword">else</span> <span class="VarId">try</span> <span class="VarId">sqlString</span>
                 <span class="Symbol">&lt;|&gt;</span> <span class="VarId">try</span> <span class="VarId">idString</span>
                 <span class="Symbol">&lt;|&gt;</span> <span class="VarId">try</span> <span class="VarId">positionalArg</span>
                 <span class="Symbol">&lt;|&gt;</span> <span class="VarId">try</span> <span class="VarId">sqlSymbol</span>
                 <span class="Symbol">&lt;|&gt;</span> <span class="VarId">try</span> <span class="VarId">sqlFloat</span>
                 <span class="Symbol">&lt;|&gt;</span> <span class="VarId">try</span> <span class="VarId">sqlInteger</span>
           <span class="VarId">updateState</span> <span class="Symbol">$</span> <span class="Symbol">\</span><span class="VarId">stt</span> <span class="Symbol">-&gt;</span>
             <span class="Keyword">case</span> <span class="Symbol">()</span> <span class="Keyword">of</span>
                     <span class="VarId">_</span> <span class="Symbol">|</span> <span class="VarId">stt</span> <span class="Symbol">==</span> <span class="Symbol">[]</span> <span class="Symbol">&amp;&amp;</span> <span class="VarId">t</span> <span class="Symbol">==</span> <span class="VarId">ft</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">]</span>
                       <span class="Symbol">|</span> <span class="VarId">stt</span> <span class="Symbol">==</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">]</span> <span class="Symbol">&amp;&amp;</span> <span class="VarId">t</span> <span class="Symbol">==</span> <span class="VarId">st</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">,</span><span class="VarId">st</span><span class="Symbol">]</span>
                       <span class="Symbol">|</span> <span class="VarId">stt</span> <span class="Symbol">==</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">,</span><span class="VarId">st</span><span class="Symbol">]</span> <span class="Symbol">&amp;&amp;</span> <span class="VarId">t</span> <span class="Symbol">==</span> <span class="VarId">mt</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[</span><span class="VarId">ft</span><span class="Symbol">,</span><span class="VarId">st</span><span class="Symbol">,</span><span class="VarId">mt</span><span class="Symbol">]</span>
                       <span class="Symbol">|</span> <span class="VarId">otherwise</span> <span class="Symbol">-&gt;</span> <span class="Symbol">[]</span>

           <span class="VarId">return</span> <span class="Symbol">(</span><span class="VarId">sp</span><span class="Symbol">,</span><span class="VarId">t</span><span class="Symbol">)</span>
           <span class="Keyword">where</span>
             <span class="VarId">ft</span> <span class="Symbol">=</span> <span class="ConId">IdStringTok</span> <span class="String">&quot;from&quot;</span>
             <span class="VarId">st</span> <span class="Symbol">=</span> <span class="ConId">IdStringTok</span> <span class="String">&quot;stdin&quot;</span>
             <span class="VarId">mt</span> <span class="Symbol">=</span> <span class="ConId">SymbolTok</span> <span class="String">&quot;;&quot;</span></pre></div></div></div><p
    >== specialized token parsers</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">sqlString</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">sqlString</span> <span class="Symbol">=</span> <span class="VarId">stringQuotes</span> <span class="Symbol">&lt;|&gt;</span> <span class="VarId">stringLD</span>
  <span class="Keyword">where</span>
    <span class="Comment">--parse a string delimited by single quotes</span>
    <span class="VarId">stringQuotes</span> <span class="Symbol">=</span> <span class="ConId">StringTok</span> <span class="String">&quot;\'&quot;</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">stringPar</span>
    <span class="VarId">stringPar</span> <span class="Symbol">=</span> <span class="VarId">optional</span> <span class="Symbol">(</span><span class="VarId">char</span> <span class="Char">'E'</span><span class="Symbol">)</span> <span class="Symbol">*&gt;</span> <span class="VarId">char</span> <span class="Char">'\''</span>
                <span class="Symbol">*&gt;</span> <span class="VarId">readQuoteEscape</span> <span class="Symbol">&lt;*</span> <span class="VarId">whiteSpace</span>
    <span class="Comment">--(readquoteescape reads the trailing ')</span></pre></div></div></div><p
    >have to read two consecutive single quotes as a quote character instead of the end of the string, probably an easier way to do this</p
    ><p
    >other escapes (e.g.  ) are left unprocessed</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">    <span class="VarId">readQuoteEscape</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
                      <span class="VarId">x</span> <span class="Symbol">&lt;-</span> <span class="VarId">anyChar</span>
                      <span class="Keyword">if</span> <span class="VarId">x</span> <span class="Symbol">==</span> <span class="Char">'\''</span>
                        <span class="Keyword">then</span> <span class="VarId">try</span> <span class="Symbol">((</span><span class="VarId">x</span><span class="Symbol">:)</span> <span class="Symbol">&lt;$&gt;</span> <span class="Symbol">(</span><span class="VarId">char</span> <span class="Char">'\''</span> <span class="Symbol">*&gt;</span> <span class="VarId">readQuoteEscape</span><span class="Symbol">))</span>
                             <span class="Symbol">&lt;|&gt;</span> <span class="VarId">return</span> <span class="String">&quot;&quot;</span>
                        <span class="Keyword">else</span> <span class="Symbol">(</span><span class="VarId">x</span><span class="Symbol">:)</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">readQuoteEscape</span></pre></div></div></div><p
    >parse a dollar quoted string</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode">    <span class="VarId">stringLD</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
               <span class="Comment">-- cope with $$ as well as $[identifier]$</span>
               <span class="VarId">tag</span> <span class="Symbol">&lt;-</span> <span class="VarId">try</span> <span class="Symbol">(</span><span class="VarId">char</span> <span class="Char">'$'</span> <span class="Symbol">*&gt;</span> <span class="Symbol">((</span><span class="VarId">char</span> <span class="Char">'$'</span> <span class="Symbol">*&gt;</span> <span class="VarId">return</span> <span class="String">&quot;&quot;</span><span class="Symbol">)</span>
                                   <span class="Symbol">&lt;|&gt;</span> <span class="Symbol">(</span><span class="VarId">identifierString</span> <span class="Symbol">&lt;*</span> <span class="VarId">char</span> <span class="Char">'$'</span><span class="Symbol">)))</span>
               <span class="VarId">s</span> <span class="Symbol">&lt;-</span> <span class="VarId">lexeme</span> <span class="Symbol">$</span> <span class="VarId">manyTill</span> <span class="VarId">anyChar</span>
                      <span class="Symbol">(</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">char</span> <span class="Char">'$'</span> <span class="Symbol">&lt;*</span> <span class="VarId">string</span> <span class="VarId">tag</span> <span class="Symbol">&lt;*</span> <span class="VarId">char</span> <span class="Char">'$'</span><span class="Symbol">)</span>
               <span class="VarId">return</span> <span class="Symbol">$</span> <span class="ConId">StringTok</span> <span class="Symbol">(</span><span class="String">&quot;$&quot;</span> <span class="Symbol">++</span> <span class="VarId">tag</span> <span class="Symbol">++</span> <span class="String">&quot;$&quot;</span><span class="Symbol">)</span> <span class="VarId">s</span>

<span class="Function">idString</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">idString</span> <span class="Symbol">=</span> <span class="ConId">IdStringTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">identifierString</span>

<span class="Function">positionalArg</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">positionalArg</span> <span class="Symbol">=</span> <span class="VarId">char</span> <span class="Char">'$'</span> <span class="Symbol">&gt;&gt;</span> <span class="ConId">PositionalArgTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">integer</span></pre></div></div></div><p
    >Lexing symbols:</p
    ><pre
    ><code
      >approach 1:
try to keep multi symbol operators as single lexical items
(e.g. &quot;==&quot;, &quot;~==&quot;

approach 2:
make each character a separate element
e.g. == lexes to ['=', '=']
then the parser sorts this out

Sort of using approach 1 at the moment, see below

== notes on symbols in pg operators
pg symbols can be made from:

=_*/&lt;&gt;=~!@#%^&amp;|`?

no --, /* in symbols

can't end in + or - unless contains
~!@#%^&amp;|?

Most of this isn't relevant for the current lexer.

== sql symbols for this lexer:

sql symbol is one of
()[],; - single character
+-*/&lt;&gt;=~!@#%^&amp;|`? string - one or more of these, parsed until hit char
which isn't one of these (including whitespace). This will parse some
standard sql expressions wrongly at the moment, work around is to add
whitespace e.g. i think 3*-4 is valid sql, should lex as '3' '*' '-'
'4', but will currently lex as '3' '*-' '4'. This is planned to be
fixed in the parser.
.. := :: : - other special cases
A single * will lex as an identifier rather than a symbol, the parser
deals with this.
</code
      ></pre
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">sqlSymbol</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">sqlSymbol</span> <span class="Symbol">=</span>
  <span class="ConId">SymbolTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">lexeme</span> <span class="Symbol">(</span><span class="VarId">choice</span> <span class="Symbol">[</span>
                         <span class="VarId">replicate</span> <span class="Number">1</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">oneOf</span> <span class="String">&quot;()[],;&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">string</span> <span class="String">&quot;..&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">string</span> <span class="String">&quot;.&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">string</span> <span class="String">&quot;::&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">string</span> <span class="String">&quot;:=&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">string</span> <span class="String">&quot;:&quot;</span>
                        <span class="Symbol">,</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">string</span> <span class="String">&quot;$(&quot;</span> <span class="Comment">-- antiquote standard splice</span>
                        <span class="Symbol">,</span><span class="VarId">try</span> <span class="Symbol">$</span> <span class="VarId">string</span> <span class="String">&quot;$s(&quot;</span> <span class="Comment">-- antiquote string splice</span>
                        <span class="Symbol">,</span><span class="VarId">string</span> <span class="String">&quot;$i(&quot;</span> <span class="Comment">-- antiquote identifier splice</span>
                        <span class="Symbol">,</span><span class="VarId">many1</span> <span class="Symbol">(</span><span class="VarId">oneOf</span> <span class="String">&quot;+-*/&lt;&gt;=~!@#%^&amp;|`?&quot;</span><span class="Symbol">)</span>
                        <span class="Symbol">])</span>

<span class="Function">sqlFloat</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">sqlFloat</span> <span class="Symbol">=</span> <span class="ConId">FloatTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">float</span>

<span class="Function">sqlInteger</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">sqlInteger</span> <span class="Symbol">=</span> <span class="ConId">IntegerTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">integer</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >additional parser bits and pieces</p
    ><p
    >include dots, * in all identifier strings during lexing. This parser is also used for keywords, so identifiers and keywords aren't distinguished until during proper parsing, and * and qualifiers aren't really examined until type checking</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">identifierString</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">String</span>
<span class="Function">identifierString</span> <span class="Symbol">=</span> <span class="VarId">lexeme</span> <span class="Symbol">$</span> <span class="VarId">choice</span> <span class="Symbol">[</span>
                    <span class="String">&quot;*&quot;</span> <span class="Symbol">&lt;$</span> <span class="VarId">symbol</span> <span class="String">&quot;*&quot;</span>
                   <span class="Symbol">,</span><span class="VarId">nonStarPart</span><span class="Symbol">]</span>
  <span class="Keyword">where</span>
    <span class="VarId">nonStarPart</span> <span class="Symbol">=</span> <span class="VarId">idpart</span> <span class="Symbol">&lt;|&gt;</span> <span class="Symbol">(</span><span class="VarId">char</span> <span class="Char">'&quot;'</span> <span class="Symbol">*&gt;</span> <span class="VarId">many</span> <span class="Symbol">(</span><span class="VarId">noneOf</span> <span class="String">&quot;\&quot;&quot;</span><span class="Symbol">)</span> <span class="Symbol">&lt;*</span> <span class="VarId">char</span> <span class="Char">'&quot;'</span><span class="Symbol">)</span>
                  <span class="Keyword">where</span> <span class="VarId">idpart</span> <span class="Symbol">=</span> <span class="Symbol">(</span><span class="VarId">letter</span> <span class="Symbol">&lt;|&gt;</span> <span class="VarId">char</span> <span class="Char">'_'</span><span class="Symbol">)</span> <span class="Symbol">&lt;:&gt;</span> <span class="VarId">secondOnwards</span>
    <span class="VarId">secondOnwards</span> <span class="Symbol">=</span> <span class="VarId">many</span> <span class="Symbol">(</span><span class="VarId">alphaNum</span> <span class="Symbol">&lt;|&gt;</span> <span class="VarId">char</span> <span class="Char">'_'</span><span class="Symbol">)</span></pre></div></div></div><p
    >parse the block of inline data for a copy from stdin, ends with . on its own on a line</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">copyPayload</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Tok</span>
<span class="Function">copyPayload</span> <span class="Symbol">=</span> <span class="ConId">CopyPayloadTok</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">lexeme</span> <span class="Symbol">(</span><span class="VarId">getLinesTillMatches</span> <span class="String">&quot;\\.\n&quot;</span><span class="Symbol">)</span>
  <span class="Keyword">where</span>
    <span class="VarId">getLinesTillMatches</span> <span class="VarId">s</span> <span class="Symbol">=</span> <span class="Keyword">do</span>
                            <span class="VarId">x</span> <span class="Symbol">&lt;-</span> <span class="VarId">getALine</span>
                            <span class="Keyword">if</span> <span class="VarId">x</span> <span class="Symbol">==</span> <span class="VarId">s</span>
                              <span class="Keyword">then</span> <span class="VarId">return</span> <span class="String">&quot;&quot;</span>
                              <span class="Keyword">else</span> <span class="Symbol">(</span><span class="VarId">x</span><span class="Symbol">++)</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">getLinesTillMatches</span> <span class="VarId">s</span>
    <span class="VarId">getALine</span> <span class="Symbol">=</span> <span class="Symbol">(++</span><span class="String">&quot;\n&quot;</span><span class="Symbol">)</span> <span class="Symbol">&lt;$&gt;</span> <span class="VarId">manyTill</span> <span class="VarId">anyChar</span> <span class="Symbol">(</span><span class="VarId">try</span> <span class="VarId">newline</span><span class="Symbol">)</span>

<span class="Comment">{-tryMaybeP :: GenParser tok st a</span>
<span class="Comment">          -&gt; ParsecT [tok] st Identity (Maybe a)</span>
<span class="Comment">tryMaybeP p = try (optionMaybe p) &lt;|&gt; return Nothing-}</span></pre></div></div></div><p
    >================================================================================</p
    ><p
    >= parsec pass throughs</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">symbol</span> <span class="Symbol">::</span> <span class="ConId">String</span> <span class="Symbol">-&gt;</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">String</span>
<span class="Function">symbol</span> <span class="Symbol">=</span> <span class="ConId">P.</span><span class="VarId">symbol</span> <span class="VarId">lexer</span>

<span class="Function">integer</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Integer</span>
<span class="Function">integer</span> <span class="Symbol">=</span> <span class="VarId">lexeme</span> <span class="Symbol">$</span> <span class="ConId">P.</span><span class="VarId">integer</span> <span class="VarId">lexer</span>

<span class="Function">float</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="ConId">Double</span>
<span class="Function">float</span> <span class="Symbol">=</span> <span class="VarId">lexeme</span> <span class="Symbol">$</span> <span class="ConId">P.</span><span class="VarId">float</span> <span class="VarId">lexer</span>

<span class="Function">whiteSpace</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="Symbol">()</span>
<span class="Function">whiteSpace</span><span class="Symbol">=</span> <span class="ConId">P.</span><span class="VarId">whiteSpace</span> <span class="VarId">lexer</span>

<span class="Function">lexeme</span> <span class="Symbol">::</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="VarId">a</span>
          <span class="Symbol">-&gt;</span> <span class="ConId">ParsecT</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span> <span class="VarId">a</span>
<span class="Function">lexeme</span> <span class="Symbol">=</span> <span class="ConId">P.</span><span class="VarId">lexeme</span> <span class="VarId">lexer</span></pre></div></div></div><p
    >this lexer isn't really used as much as it could be, probably some of the fields are not used at all (like identifier and operator stuff)</p
    ><div class='sourceCode'><div class='literate'><div class='haskell'><pre class="sourceCode"><span class="Function">lexer</span> <span class="Symbol">::</span> <span class="ConId">P.GenTokenParser</span> <span class="ConId">String</span> <span class="ConId">LexState</span> <span class="ConId">Identity</span>
<span class="Function">lexer</span> <span class="Symbol">=</span> <span class="ConId">P.</span><span class="VarId">makeTokenParser</span> <span class="Symbol">(</span><span class="VarId">emptyDef</span> <span class="Symbol">{</span>
                            <span class="ConId">P.</span><span class="VarId">commentStart</span> <span class="Symbol">=</span> <span class="String">&quot;/*&quot;</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">commentEnd</span> <span class="Symbol">=</span> <span class="String">&quot;*/&quot;</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">commentLine</span> <span class="Symbol">=</span> <span class="String">&quot;--&quot;</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">nestedComments</span> <span class="Symbol">=</span> <span class="ConId">False</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">identStart</span> <span class="Symbol">=</span> <span class="VarId">letter</span> <span class="Symbol">&lt;|&gt;</span> <span class="VarId">char</span> <span class="Char">'_'</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">identLetter</span>    <span class="Symbol">=</span> <span class="VarId">alphaNum</span> <span class="Symbol">&lt;|&gt;</span> <span class="VarId">oneOf</span> <span class="String">&quot;_&quot;</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">opStart</span>        <span class="Symbol">=</span> <span class="ConId">P.</span><span class="VarId">opLetter</span> <span class="VarId">emptyDef</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">opLetter</span>       <span class="Symbol">=</span> <span class="VarId">oneOf</span> <span class="VarId">opLetters</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">reservedOpNames</span><span class="Symbol">=</span> <span class="Symbol">[]</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">reservedNames</span>  <span class="Symbol">=</span> <span class="Symbol">[]</span>
                           <span class="Symbol">,</span><span class="ConId">P.</span><span class="VarId">caseSensitive</span>  <span class="Symbol">=</span> <span class="ConId">False</span>
                           <span class="Symbol">})</span>

<span class="Function">opLetters</span> <span class="Symbol">::</span> <span class="ConId">String</span>
<span class="Function">opLetters</span> <span class="Symbol">=</span> <span class="String">&quot;.:^*/%+-&lt;&gt;=|!&quot;</span></pre></div></div></div><br
     /><br
     /><br
     /><div class="footer"
    >generated on 01/31/11 20:00:52, hssqlppp-0.3.0</div
    ></body
  ></html
>
