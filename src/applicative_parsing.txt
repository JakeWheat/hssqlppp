# Applicative Parsing

Most of the parser is written in something called applicative
style. This is sort of a variant on monadic style parsing which is
what most of the examples for parsec you find are written
in. (Applicative style was developed for parsing, but has many more
applications.)

This is a short pragmatic example based guide.

The way I originally got applicative parsing (yes, it seems simple but
it took me ages to work it out) was by writing parsers like this:

~~~ {.haskell}
integerLit = do
    p <- pos
    i <- integer
    return $ IntegerLit p i
~~~

and thinking, there must be a way to write it in one step, without the
temporary names.

Applicative parsing comes to the rescue:

~~~ {.haskell}
integerLit = IntegerLit <$> pos <*> integer
~~~

It reduces the amount of boilerplate for simple parsing functions.

To get started, I would write out the first version using the
conventional monad style, then convert piecemeal to applicative style:

~~~ {.haskell}
integerLit = do
    p <- pos
    i <- integer
    return $ IntegerLit p i
~~~

~~~ {.haskell}
integerLit = do
    p <- pos
    (IntegerLit p) <$> integer
~~~

~~~ {.haskell}
integerLit = do
    IntegerLit <$> pos <*> integer
~~~

~~~ {.haskell}
integerLit = IntegerLit <$> pos <*> integer
~~~

After getting comfortable with this, it becomes much easier to write
the parsers in applicative style directly compared to monad style, and
easier to read as well. When I got stuck editing applicative style
parsers before I was fluent in them, I would revert any changes,
convert the applicative style parser to monadic style, apply my
changes in the monadic style, test it works, then convert it back to
applicative in stages until I was happy with it.

## Some rules:

~~~ {.haskell}
parser = do
   a <- subParser1
   b <- subParser2
   c <- subParser3
   d <- subParser4
   return $ AstNode a b c d
~~~

is converted like this:

~~~ {.haskell}
parser = AstNode <$> subParser1 <*> subParser2 <*> subParser3 <*> subParser4
~~~

~~~ {.haskell}
parser = do
   a <- subParser1
   return $ AstNode1 a
~~~

would be

~~~ {.haskell}
parser = AstNode1 <$> subParser1
~~~

and

~~~ {.haskell}
parser = do
   a <- subParser1
   b <- subParser2
   return $ AstNode2 a b
~~~

would be

~~~ {.haskell}
parser = AstNode2 <$> subParser1 <*> subParser2
~~~

The main thing to notice is that you follow the pure constructor
AstNodeX with `<$>` and the first argument, then to add additional
arguments you use `<*>`.

What's nice about this is that the parser looks similar to creating a
pure value:

~~~ {.haskell}
parser = AstNode <$> subParser1 <*> subParser2 <*> subParser3 <*> subParser4
~~~

~~~ {.haskell}
value = AstNode subValue1 subValue2 subValue4 subValue4
~~~

The limitations are that it is difficult to convert the following
monadic parsers into applicative syntax.

~~~ {.haskell}
parser = do
   a <- subParser1
   b <- subParser2
   return $ AstNode2 b a
~~~

The values are passed to the constructor in the reverse order to the
order in which they are parsed. Here is a way to make this work:

~~~ {.haskell}
parser = revAstNode2 <$> a <*> b
  where
    revAstNode2 a b = AstNode2 b a -- can use flip here as well
~~~

There may also be performance implications when using applicative
compared to monadic (applicative might be faster or use less memory in
some circumstances) but I don't know much about this.

## Ignoring the results of parsers

What about this:

~~~ {.haskell}
createView = do
  p <- pos
  _ <- keyword "view"
  i <- idString
  _ <- keyword "as"
  e <- selectExpression
  return $ CreateView p i e
~~~

(If this parser for a sql create view statement doesn't look quite
right it may be because it is only called when the initial 'create'
keyword has already been parsed.)

Can this be rewritten even though it ignores the results of some of
the parsers (e.g. '`_ <- keyword "view"`')?

This is how it is done:

~~~ {.haskell}
createView = CreateView
             <$> (pos <* keyword "view")
             <*> idString
             <*> (keyword "as" *> selectExpression)
~~~

If this is broken down, you can see how it works:

~~~ {.haskell}
createView = CreateView
             <$> posThenIgnoreView
             <*> idString
             <*> ignoreAsThenSelectExpression
             where
               posThenIgnoreView = do
                 p <- pos
                 _ <- keyword "view"
                 return p
               ignoreAsThenSelectExpression = do
                 _ <- keyword "as"
                 e <- selectExpression
                 return e
                 -- or just
                 -- _ <- keyword "as"
                 -- selectExpression
~~~

This shows the code using the applicative style without any
tricks. The operators `<*` and `*>` are used to run subparsers, and
ignore the results:

~~~ {.haskell}
createView = CreateView
             <$> posAndIgnoreView
             <*> idString
             <*> ignoreAsAndSelectExpression
             where
               posAndIgnoreView =
                 pos <* keyword "view"
               ignoreAsAndSelectExpression =
                 keyword "as" *> selectExpression
~~~

Basically, `<*` runs the parser to the left, then the one to the
right, and returns the result of the left parser and ignores the
result of the right parser:

~~~ {.haskell}
a <* b = do
  a' <- a
  _ <- b
  return a
~~~

(This is equivalent to what happens, but not the actual implementation.)

This leads to the final implementation:

~~~ {.haskell}
createView = CreateView
             <$> (pos <* keyword "view")
             <*> idString
             <*> (keyword "as" *> selectExpression)
~~~

`*>` is a lot like `>>` which is used with monads.


## Ignoring the results of parsers 2

~~~ {.haskell}
booleanLit = do
  p <- pos
  v <- ((do
         _ <- keyword "true"
         return True)
        <|>
        (do
         _ <- keyword "false"
         return False))
  return $ BooleanLit p v
~~~

In this case, we are ignoring the parser result completely, and
returning a pure value. You can rewrite this using `*>` and returns, but
there is a shorter way:

~~~ {.haskell}
booleanLit = do
  p <- pos
  v <- ((True <$ keyword "true")
        <|>
        (do
         _ <- keyword "false"
         return False))
  return $ BooleanLit p v
~~~

The `<$` operator returns the first argument which is pure, if the
second argument succeeds (and ignores the result of the second
argument). I think it is mainly used in this way to parse to
parameterless constructors. Finishing off rewriting `booleanLit`:

~~~ {.haskell}
booleanLit = do
  p <- pos
  v <- ((True <$ keyword "true")
        <|>
        (False <$ keyword "false"))
  return $ BooleanLit p v
~~~

~~~ {.haskell}
booleanLit = BooleanLit <$> pos <*> ((True <$ keyword "true")
                                     <|>
                                     (False <$ keyword "false"))
~~~

There is some information in Real World Haskell:

[http://book.realworldhaskell.org/read/using-parsec.html](http://book.realworldhaskell.org/read/using-parsec.html)

The section is called 'Applicative functors for parsing' (Applicative
is type class which sits inbetween functors and monads).

Here is another page:

[http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/](http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/)

Make sure you check out Brent Yorgey's (2nd) comment at the bottom.
