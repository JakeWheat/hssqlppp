immediate todo:
rearrange all files under src/, redo the index.txts
add parsing the chaos files to the automated tests
sql lexer for illuminate
fold in changes from selects branch, start work on tpc-h parsing

new todo for 0.3.0
fix expression parsing
support most postgresql syntax
better approach wrt parse tree and ast
production type checking for selects, and dml?
use doctool for documentation, upload to github
refactor tests to reorganise
fix up website
add examples page to website
report generator
hssqlppputil work
simple syntax extensions support
build script to do uuagc, antinodes, etc.
quasi quoting: lots more splices, pluc embedded haskell syntax
get chaos parsing and working properly, add to tests
do wrappers
revert plan with selects branch: fold changes in selects branch back
   into trunk and discontinue selects branch. Want a less disruptive
   improvement - fix query typechecking whilst keeping other stuff in
   current condition





new medium term goal
packages:
sqlppp: sql ast + parsetree?, parser, pretty printer, quasi quotes, syntax
       extension support, typechecking
relationalalgebra: ra ast? or really non ra specific ast?
   parser, pretty printer, quasi quotes, + for relational calculus too
   type checking
sql-ra: convert sql to ra and vice versa, transforms to try to produce
   idiomatic sql or ra, make the round trips be id
relational algebra implementation uaing dph
sql implementation using dph via ra
relational algebra implementation via conversion to sql


type checking sql is too much of a mess, so take a break:
relational algebra + calculus work


= TODOs

This file is a complete disorganised mess.

release plan:

0.3.0

try to get some sort of wrapper working
check over documentation & write todo
heading hack?
sql syntax highlighting for illuminate?
do new develtool exe -> runs makeantinodes, makewebsite, and generate
  defaulttemplate1catalog lhs
write roundtriptest exe, run with chaos and check out issues
disable failing tests
figure out haddock issue
see how easy to get chaos mostly typechecking again
hssqlppputil code is crap - fix it

0.4.0

Parsing: most of the pg manual, note what isn't yet supported
typechecking: enough to get chaos working? - want to at least support
   simple typesafe access
quasi quoting: add loads of splices, add switch for parsing
catalog: review what is missing, add a bunch of it
local bindings: needs another complete rethink, a design and better
   tests
documentation work: literate comments, txt files, doctool work
custom syntax support
report function: roundtrip, documentation generator, type checking
examples
lots of small fixes

-----

future

serious profiling: optimise speed and memory use
split parse tree and ast?
 - maybe can parse operators properly here?
integrate with haskelldb so can mix sql and haskelldb together?
nullability inference: might be a bit difficult, maybe use a haskelldb inspired approach?
more annotations
ability to produce heavily cross linked docs + diagrams



-----










rewrite docs, add nav
sort out typechecking basics, bit of a mess atm
add parsing support for most pg stuff
add a bunch of quasi quote support
bunch of simple example programs, add automated tests for these
work on doc tool, make it less flakey
work on the transformed sql renderer, try to make it a bit less buggy
   and less spaghetti
work on the literate docs, especially in the typechecking code
add chaos sql as test(s)
finish round trip tests/doc with catalog, typecheck failures, etc.
catalog extras, review what is missing
extension work: module extension with doc tool support
extensions: materialized view, temporal data?, inclusion thing
get simple haskell wrapper generator, plus hlist version
restart with tests, organise and make systematic as examples/reference
  as well as tests
command line construction tool?
database connection, bunch of other little things
simple custom syntax support





-----------------------

New todo for next release:

chaos:
fix ui so works
effects, animation
ai working

fix documentation generator
finish wrappers and examples
database connection
nav for website

???
use cases:
parse some sql: expression, files, etc.
 produce: ast, see parse errors, just check things parse ok
type check:
  -> view resultant catalog
     compare catalog with pg
     view annotated source
     view annotated ast
     see type errors
typesafe database access
use the parser in an embedded situation
use quasiquoting
write some extensions, then load sql using those extensions into a
   database

whet your appetite page: just some code snippets and short
   description with some links, like a marketing page

--

report:
remove original annotate source
integrate with testbattery
provide output in valid sql text or pandoc->html
ability to read database rather than sql
integrate with ppcatalog, dbcatalog

some of the small fixes:

add abstract to 6nf - base class abstract, and intermediate class
   abstract. what about disjoint base classes?


New plan to combine testbattery, annotate source, etc.
input: database name, sql files, ast tranformer
  - maybe make database reading optional
  - maybe make option to read from database rather than sql source
produces in a directory tree (bits are switch-offable with flags):
each original source file unchanged
transformed and annotated source of each file
a page listing the type errors with links
a page displaying the catalog that the type check has produced
a page summarising the round trip process:
  errors on trying to load into database
  differences in catalog read from database to one from type checker
  errors parsing the database dump
  differences in catalog from typechecking the dump to the original
   source catalog
  list of type errors from checking the dump, with comparison with
   type errors from original source
output targets:
html
txt - valid sql for the transformed files
also want to run from the command line and just highlight the catalog
   differences and type errors like an emacs compile
would be really nice if the catalog page served as an index, so we can
   jump to the definitions from there.



----------

add a load of quasiquoting support, with tests ->1quote fns, and
   splices
 - make this usable by providing good tests for examples, so you can
   search by ast element, or sql code, for the splice spelling/example
   code.
add wildcards for quasiquoting?
add switches for parsing quasiquotes

issues for an announcement on freshment, postgresql: - next plus one release
parsing - add parsing support for all template1 operators, plus try to add
   most of the syntax in the manual



add flag to parser to switch between parsing splices or not
convert error to either in conversion from anti to regular ast

sort out documentation:
fix data: make hssqlsystem nicer, work on wrapper examples and
  library source files
nav: create a 'sitemap' thing, and nav bar and breadcrumbs to each
   page
work on rendering source - issues with markdown, embedded sql, etc.

add tests for extensions actually working by using them in a database

focus: website/documentation, examples
       missing catalog elements: triggers, sequences, constraints, indexes, defaults
       do command line wrapper generator thing for hssqlsystem
       do examples processor for hssqlsystem
       work on extensions for chaos - get completed, change how tests
         are done, etc., sort out chaos code itself. One idea, robbed
         from makelabels in hlist, is to write an example bit of
         target sql for each extension, parse this, then use generics to swap in
         the correct identifiers - like a poor mans quasi-quoting.
         find a way to get listen working from haskell
       work on roundtrip tests - get working for chaos
doc work todos:
check pandoc & haddock slowness with defaulttemplate1catalog
check pandoc hang with big ast in hssqlsystem example, other places
tidy code, get rendering nicely with pandoc


idea for example code in haddock: put the example code in self
   contained lhs files which can be compiled and run, then either link
   or include this source into the haddock. otherwise this stuff goes
   stale which is really bad to serve as an example.

for the web site: for each file generated from source, txt, sql, lhs,
   etc., link to the actual source code file.

also:
get returning * working, count *
fix how implicit joins type check now that code has been refactored to
   make this easy

then:
make list of loose ends, syntax and missing type checks - lots of
   missing checks when updating catalog
convert type to Maybe TypeInfo, add a bunch of newtypes, typedefs,
   etc., separate out types and add some sum types to make more
   typesafe, investigate first
error handling
nullability inference
find a way of doing database connections better: full command line
   options, ability to prompt for password, config file support, and
   support for full connection options, e.g. host and port as well as
   db name.
look into pretty printing: type errors, annotations, cat diffs are big
   areas which are currently crap

-----------
old New approach:
list todos for next release or next few releases
lists todos for first alpha release
list future plans/ ideas

for alpha release
review unsupported syntax and make list to be done for alpha and what
   will not be done
typechecking - want all parsable syntax to type check properly as much
   as possible
fix lexing of symbols, e.g. =? doesn't work
add parsing and typechecking support at least for all operators in
   default catalog

future plans:
much more annotations - account of function match lookup process,
   inferred types, references to definition point e.g. for local
   identifiers, and all sorts
better extensions to plpgsql
better macro system for plpgsql
support for typeclasses, monads, algebraic datatypes and pattern matching?
possibly break into multiple packages
documentation generator for plpgsql and database

notes about parse tree:
would like to support things like making not null the default for
   table columns rather than null.
can't do this at the moment since implicit null and explicit null both
   look the same in the ast after parsing
so, go whole hog: think about parsing to a modified ast which tries to
   accurately represent the source code itself, so we can pretty print
   back and e.g. not add implicit defaults, add parens, etc.
then have a canonicalize process which adds in all the defaults
think about how flexible this should be:
1) force all type checked trees to be canonicalized -> nice and simple
2) allow typechecking of non canonicalized trees -> will make type
   checking more complicated, but also remove the need for a separate
   set of data types for the parse tree and the aast.
what about putting explicit parenthesis in this parse tree, this might
   make it feasible to support the full range of operators that
   postgresql supports, and support e.g. the creation of an operator
   followed by it's use

some other ideas

show used catalog, work with module extension as well
better pretty printers for annotation types
extensions code tidy?
annotation generics style
non sql syntax extensions work - need a set of hooks, a separate
   module which exposes all the parser combinators, and some extended
   parse functions //or preprocessor of some sort

convert ag files into lag for consistency - no support for birdfeet
   style in uuagc?

plpgsql stuff: blocks, assignments in declarations, strict into,
   labels,loops,continue
look into running test suite from cabal

=== types and internal errors handling

look at all the places where type lists are wrapped in
   unnamedcomposite and get rid of most of them - just use the type
   list directly.
Look at all the contexts where pg types can be used, and split into
   separate haskell types, and use sums to put them back together
   to use the haskell type system better e.g. different set of types
   can be used for an attribute in a table, for a function parameter,
   function return type, variable declaration, etc. - want to use the
   haskell type system to enforce this and get rid of a load of
   runtime checks (mainly the unwrap setof, etc. in typetype). - or is
   there a better way of doing this?

=== parse/typecheck errors to user

investigate alternative parser libs which can e.g. continue parsing
   after an error to provide more parse errors at once.
write a show for parsec errors which formats the lex tokens and
   expected lists properly (was broken when moved to the separate
   lexer)

=== schemas

think of a way to handle schemas, what about changes to schema search
   path mid code.

=== catalog and bindings annotation

Add the current bindings as annotation everywhere, this can be used by
   the ambiguous identifier checks, etc., and to understand errors
also: add annotations to the catalog so we can see where an entity in
   the catalog has come from, what update and what source
   line. similar for localbindings - use
   this for a command than can make hyperlinked source

=== casting annotation

for each casting operation, add a log which explains what the relevant
   algorithm has done to either find the appropriate cast or what it's
   considered before failing. (e.g. can provide a list of steps taken
   with the candidate lists in the findcallmatch routine, might be
   useful for errors when it can't find a match, and if it is calling
   an unexpected function instead of the one you want).

null treatment
Basic motivation is to keep nulls carefully walled off, controlled,
   and be able to catch them when they sneak back into expressions,
   etc.. For each value, etc. we determine statically if it might be
   null. This can be done for return types of functions, fields in a
   select expression, etc.. (will do mappings e.g. if a functions
   inputs are all non null, then the output is non null, etc.). Once
   this is working ok, the second stage is to implement the anti null
   warnings/ errors.
Allow nulls in tables, outer joins, in coalesce, to be produced by
   selects (maybe add or remove from this allowed list, maybe make it
   configurable on a per project basis).
Never allow nulls to be an argument to a function call, (including
   ops, keyword ops, etc.). So every time you have a field being used
   in an expression and it cannot be statically verified to be non
   null, you have to insert a coalesce or fix it in some other way.
So nulls can still be used to represent optional values, n/a,
   etc.. and output to clients doing selects, but there is no need to
   grapple with:
* 3vl (or whatever it is that sql uses instead),
* what the result of a function call is if the some or all the
  arguments are null,
* what the result of a sum aggregate is if some of the values are null,
* etc.,
because none of these things are allowed.

=== shadowed identifier test

use the bindings annotation to add warnings

=== modules extension

stage 1: set the current module with a function call
do creating the module and adding objects to the current module using
   extension instead of the sql functions used at the moment
find a way to annotate the source with modules stuff, want to use it
   for documentation
stage 2: add import/export stuff and check this

=== other extensions for chaos
mark generated code with annotation: make annotation types open with type
   class or something? - can get rid of typeerrora, statementinfoa
   wrappers this way
check for all ddl, etc. run in functions/executes and turn into
   extensions so the type checker can see these things
out of order definitions: want to write defs in any order and
   have the extension reorder them into something which can be loaded
   into postgres
finish create_var extension: add constraints
constraint system: make a bunch of stuff automatic, like using 'pg
   accelerators'
add notify triggers automatically, including for views
convert the sql tests (maybe some of the haskell tests) into static
   checks on the ast
find a better way to work with the tables with null fields:
  initial values - the copy statements are completely unreadable and
   uneditable
  what else? - what combinations of fields can be null at the same
   time?
crufty bits to try and simplify: turn sequence progression, action
   valid tables, ai
see if can make the multiple update hack more automatic

=== development/deployment support:
build file for development, just lists sql files in order, and lists
   which extensions are used - this will be a haskell/ config file,
   which uses a library to make it executable
deployment: use system to load all sql via extensions into pg, then
to a regular pg dump which can then be deployed - have automated thing
   for this

think about where can use quickcheck

=== testing
work on making the tests more comprehensive, want a test for each
   branch/option where feasible - get some coverage testing on, don't
   know how well this will work with uuagc generated code - maybe add
   a cull unused uuagc generated code utility -> think this isn't too
   difficult, parse the output of ghc -Wall, then use haskell-src-exts.

=== precedence and operator parsing
add missing operators to parser
see if @ as prefix and infix just works in parsec
some a_expr and b_expr support properly by looking at pg grammar file

is it possible to write a system that allows either writing syntax
   extensions using plpgsql like syntax, or write processors/report
   generators in extended plpgsql which use the ast or type
   information?

---------
some random notes

literal sql mode, with workspace idea: can write code/sql inline
in the source, and run it against a database and view the results
inline like in some text books where code is executed then the results
printed inline into the result - so this is a partial replacement for
   ghci, emacs haskell-mode ghci, psql, maybe bash, maybe ide, and
   also a runtime diagnosis tool which can be embedded into production
   exes. Pretty ambitious, need to focus on useful and easy features.

variant:
hssqlppp workspace: text view can type in commands and get results
   back, create multiple workspaces and they're persistent, maybe
   a wrapper round ghci but not conventional repl style, more like
   entering elisp and evaluating it in emacs? want to use
   as replacement for the ghci thing in emacs, and as a shell for working with
   the ast stuff and actual databases

use template haskell to simplify generics in extensions: cases and
   replacements are a bit verbose and difficult to write and read?


= parse and/or type check todo list:
(rough/incomplete)
"identifier"
6.5e-5
type 'string' style type cast
[:] slice
missing keyword ops
default template1 operators should all parse
agg(all expr) agg(distinct expr), agg(*)
window frame clauses, named windows
parse inside string literals when cast, for common types
multidimensional arrays
default values
serial
make sure can type check everything that parses
constraint names
provide list of keys in info for create/alter table: include unique
   not null and serials
type check fks, and other constraints
alter table: add/remove column
                        constraint
                        default value
                        column type
                        rename column
                        rename table
what other alters/creates
views, functions, operators, types, domains, triggers, rules
selects:
implicit joins
group by, having + group by with unaggregated and aggregated fields
distinct, on
order by - do properly
limit, offset
with queries
type modifiers
data type names with spaces in them
timestamps
schemas
alternative text for true and false
enums
geometric types weird syntax
composites: selector variants, rowctors, component get/update
do all keyword and template1 operators
any/some/all subqueries and arrays
check over rowwise comparisons
indexes: create/alter/drop

another todo list:
catalog:
constraints, pg_constraint
triggers
rules
indexes
add drops for all creates
review which alters to add
default columns values + insert checking
support pks,fks better
support serial properly
type modifiers
sequences
enums
listen, notify, pg_listener
blocks in plpgsql, assignments in declarations, not null checking
strict in into
lables, loops, exit, continue
raise % counts
create schema

once all this is done, work on documenting precisely what is supported
   and what isn't.

================================================================================

some syntax todo, not organised:

------------
add support for following sql syntax (+ type checking)
alter table, common variations
create index
create rule
create trigger
+ drops for all creates
+ maybe alters?
ctes
loop, exit, labels
easy ones: transactions, savepoints, listen
prepare, execute + using
some more:
create or replace
alter table
transactions: begin, checkpoint, commit, end, rollback
cursors: declare, open, fetch, move, close, where current of
copy - parse properly
create database
create index
create rule
create trigger + plpgsql support
grant,revoke
listen, notify, unlisten
prepare, execute
savepoint, release savepoint, rollback to savepoint
set, reset
set constraints
set role
set transaction
correlated subquery attrs

plpgsql

blocks which aren't at the top level of a function
% types
strict on intos
not null for var defs
exception
execute using
get diagnostics
return query execute
raise missing bits
out params
elsif
loop
exit
labels
reverse, by in for
for in execute

expressions:
process string escapes, support dollar quoting and other quoting more
   robustly in the pretty printer
full user operator support (?)
fix expression parser properly to handle things like between - see
   grammar in pg source for info on how to do this
[:] array slices
aggregate: all and distinct
multi dimensional arrays: selectors and subscripting
missing keyword operators
datetime extract
time zone
subquery operators: any, some, all
in general, parsing operators is wrong, the lexer needs to be able to
   lex sequences of symbols into single/multiple operators correctly,
   what happens at the moment is a kludge, also, general operator
   parsing will change how operators are represented in the ast

----

plpgsql on 'roids:
write libraries in haskell, and then write syntax extensions for
   plpgsql using the extension mechanism to access these libs from
   extended plpgsql e.g. ui lib written in haskell, accessed by syntax
   extensions in plpgsql then can write the database and ui all in the
   same source code in the same language, with first class support for
   properly typed relation valued expressions, avoiding multiple
   languages and mapping/'impedance mismatch' between database types
   and types in the language you write the ui in.
